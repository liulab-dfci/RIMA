[["index.html", "Tutorial of RNA-seq tumor immunity analysis Chapter 1 Introduction", " Tutorial of RNA-seq tumor immunity analysis Yang Liu, Jennifer Altreuter, Yang Lin 2022-12-05 Chapter 1 Introduction This tutorial describes how to perform integrative computational analysis of tumor immunity using bulk RNA-sequencing (RNA-seq) data. We will focus on inferring immune infiltration levels, immune repertoire features, immune response and HLA type from a gene expression profile. To support the uniform analysis of bulk RNA-sequencing data, we developed a RNA-seq immune analysis pipeline named RIMA that is available at https://github.com/liulab-dfci/RIMA_pipeline. Tumor RNA-seq has become an important technique for molecular profiling and immune characterization of tumors. RNA-seq Immune Analysis (RIMA) performs integrative computational modeling of the tumor microenvironment from bulk tumor RNA-seq data, which has the potential to offer essential insights to cancer immunology and immune-oncology studies. Figure 1.1: Flowchat of RIMA pipeline The pre-processing module includes four main procedures: Read mapping Quality control Gene quantification Batch effect removal The downstream analysis includes seven modules: Differential expression analysis Immune repertoire inference Immune infiltration estimation Immunotherapy response prediction Gene fusion Microbiome characterization Neoantigen detection Available Tools Checklist Methods Description —PREPROCESSING— STAR Spliced Transcript Alignment to a Reference Salmon Gene Quantification RSeQC High Throughput Sequence Data Evaluation batch_removal Remove Batch Effects Using Limma —DIFFERENTIAL EXPRESSION— DESeq2 Gene Differential Expression Analysis GSEA Gene Set Enrichment Analysis ssGSEA Single-sample GSEA —IMMUNE REPERTOIRE— TRUST4 TCR and BCR Sequence Analysis —IMMUNE INFILTRATION— ImmuneDeconv Cell Components Estimation —IMMUNE RESPONSE— MSIsensor2 Microsatellite Instability (MSI) Detection TIDEpy T cell dysfunction and exclusion prediction —FUSION— STAR-Fusion Identify the fusion gene pairs —MICROBIOME— Centrifuge Bacterial Abundance Detection —NEO-ANTIGEN— arcasHLA HLA Class I and Class II Genotyping "],["how-to-run-rima.html", "Chapter 2 How to run RIMA 2.1 Install RIMA and Set Up the Running Environment 2.2 Download pre-built references 2.3 Prepare input files 2.4 Running RIMA 2.5 Output", " Chapter 2 How to run RIMA “Please make sure you adhere to NIH and HIPAA security standards when uploading controlled access data to a cloud or high computing environment.” 2.1 Install RIMA and Set Up the Running Environment To run RIMA, you will create a working directory. In the working directory, you will install the pipeline code and other required software. Running machine requirements Cores and memory – We usually run RIMA on a machine with at least 64 GB of memory to ensure a smooth read alignment run using STAR. Storage – You will need to reserve enough storage for the following: 1. Reference files and pipeline code – 65 GB 2. Raw data – we recommend reserving five times the size of your data files. For example, if your fastq files are 50GB each, then you should allot 250GB for each fastq file. Zipped fastq files are recommended. 3. Required software – reserve ~20GB for installation of miniconda, mamba and snakemake. Prepare a working directory mkdir RIMA Get the pipeline code Download the RIMA_pipeline folder to your working directory. git clone https://github.com/liulab-dfci/RIMA_pipeline.git Install miniconda Download and configure your conda environment. Follow the prompts on the installer screens. #Note: You will need to install miniconda3 into the RIMA directory. This means you need to override the default directory when miniconda3 is installed. #If you have conda installed elsewhere, you will still need a local copy in your RIMA directory in order for the environment installation shell program to work. (see below) #go to your RIMA directory if you are not there already cd RIMA #obtain the Miniconda3 code and install in the RIMA directory wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh # !Don&#39;t forget to override the default directory for miniconda3! # Install miniconda3 into your RIMA directory. conda list #to see whether you have successfully installed conda Set up the running environment The RIMA environment can be set up by running a shell command. In the command, you need to specify the platform you are using – Amazon Web Services (AWS) or Google Cloud Platform (GCP). This process may take ten to fifteen minutes. The user will need to answer two questions during the process – one at the beginning of the program and one near the end – to give permissions to install miniconda and snakemake. #NOTE: before running the environment shell command, make sure to set the path for CONDA_ROOT export CONDA_ROOT=/{path_to_your_RIMA_directory}/RIMA/miniconda3 export PATH=/{path_to_your_RIMA_directory}/RIMA/miniconda3/bin:$PATH Run the shell program: #shell command for bash ./RIMA_environment.sh -p {platform --AWS, GCP} #example for AWS bash ./RIMA_environment.sh -p AWS Activate the RIMA environment Based on the conda environments information, the main environment “RIMA” can be activated as below. #set the path if you this is a new login to your shell export CONDA_ROOT=/{path_to_your_RIMA_directory}/RIMA/miniconda3 export PATH=/{path_to_your_RIMA_directory}/RIMA/miniconda3/bin:$PATH # activate the RIMA conda environment source activate RIMA 2.2 Download pre-built references A pre-prepared RIMA reference folder can be downloaded using the code below. If you want to prepare a customized reference, you can follow this tutorial to build your own reference. The following link contains the hg38 reference downloaded from Genomic Data Commons using version 22 index and annotation files. cd RIMA wget http://cistrome.org/~lyang/ref.tar.gz # unzip the reference tar -zxvf ref.tar.gz # remove the reference zip file to save some space (optional) rm ref.tar.gz Optional step If you download your RIMA reference folder into a directory other than RIMA, you have to change the symbolic link for the ref_files under the rnaseq_pipeline folder: For example: if you downloaded the RIMA reference folder into /mnt/tutorial/ref_files, use the ln command to change the symbolic link. cd RIMA # remove the current link of ref_files rm ref_files # create a new symoblic link to your reference folder ln -s /mnt/tutorial/ref_files 2.2.1 Video tutorial 2.3 Prepare input files Metasheet.csv Metasheet.csv is a comma-delimited file that resides in the RIMA_pipeline folder. The Metasheet.csv should contain phenotypic information about your samples that can be used for downstream analysis. Your metasheet should contain Two Required Columns (SampleName, Group) in comma-delimited format. For this tutorial, RIMA uses demo data from Zhao, J., Chen, A.X., Gartrell, R.D. et al. Immune and genomic correlates of response to anti-PD-1 immunotherapy in glioblastoma. Nat Med 25, 462–469 (2019). https://doi.org/10.1038/s41591-019-0349-y . We selected 12 samples from this trial and included 6 treatment naive samples (3 responder and 3 non-responders) for cohort level comparison. SampleName: Sequencing sample id. PatName: Patient id Group: Sample included for cohort level comparison. ‘NA’ indicates samples that should not be included in the comparison. In the example below, we compare responders(R) and non-responders(NR) using only treatment naive (pre) patients. You can add columns to the metasheet in order to compare other phenotypes e.g. columns for Timing Age, Sex etc. SampleName,PatName,Group,Age,Tissue,Gender,Timing,Responder,TumorLocation,OngoingTreatment,PFS,Survival,OS,SampleId,syn_batch SRR8281218,P20,NR,63,Brain,male,Pre,NR,temporal,no,110,1,278,4790-NL-AS,1 SRR8281219,P20,NA,63,Brain,male,Post,NR,temporal,no,110,1,278,4975-NL-AS,1 SRR8281226,P53,NR,70,Brain,male,Pre,NR,frontal,Yes,83,1,337,3981-NL-AS,2 SRR8281236,P53,NA,70,Brain,male,Post,NR,frontal,Yes,83,1,337,4760-D1,2 SRR8281233,P56,NR,54,Brain,female,Pre,NR,Parietal,no,83,1,83,4341-D3,3 SRR8281230,P56,NA,54,Brain,female,Post,NR,Parietal,no,83,1,83,4680-A1,3 SRR8281244,P100,NA,31,Brain,male,Post,R,Frontal-crossesmidline,yes,151,0,615,4956-NL-AS,2 SRR8281245,P100,R,31,Brain,male,Pre,R,Frontal-crossesmidline,yes,151,0,615,4595-G1,2 SRR8281243,P101,R,32,Brain,male,Pre,R,frontal,no,0,1,414,3542-NL-AS,2 SRR8281238,P102,NA,64,Brain,female,Post,R,Temporal-anterior,yes,519,0,539,5094-NL-AS,1 SRR8281251,P101,NA,32,Brain,male,Post,R,frontal,no,0,1,414,4943-A1,2 SRR8281250,P102,R,64,Brain,female,Pre,R,Temporal-anterior,yes,519,0,539,4443-NL-AS,1 Config.yaml In the RIMA_pipeline folder, we have prepared a config.yaml as a template to run the pipeline. The config file is divided into three sections: Fixed and user-defined parameters. Cohort level analysis parameters. Samples list. You should provide these parameters with column names that match the columns in metasheet.csv. Below is an example of a config.yaml file. You can set the patient name as the sample name. Note: Please make sure that sample names match the metasheet. Currently, only fastq files are accepted as input (including fastq.gz). #########Fixed and user-defined parameters################ metasheet: metasheet.csv # Meta info ref: ref.yaml # Reference config assembly: hg38 cancer_type: GBM #TCGA cancer type abbreviations rseqc_ref: house_keeping #Option: &#39;house_keeping&#39; or &#39;false&#39;. #By default, a subset of housekeeping genes is used by RSeQC to assess alignment quality. #This reduces the amount of time needed to run RSeQC. mate: [1,2] #paired-end fastq format, we recommend naming paired-end reads with _1.fq.gz and _2.fq.gz #########Cohort level analysis parameters################ design: Group # Condition on which to do comparsion (as set up in metasheet.csv) Treatment: R # Treatment use in DESeq2, corresponding to positive log fold change Control: NR # Control use in DESeq2, corresponding to negative log fold change batch: syb_batch # Options: &#39;false&#39; or a column name from the metasheet.csv. # If set to a column name in the metasheet.csv, the column name will be used for batch effect analysis (limma). # It will also be used as a covariate for differential analysis (DESeq2) to account for batch effect. pre_treated: false # Option: true or false. # If set to false, patients are treatment naive. # If set to true, patients have received some form of therapy prior to the current study. #########Samples list############## samples: SRR8281218: - /mnt/zhao_trial/data/SRR8281218_1.fastq.gz - /mnt/zhao_trial/data/SRR8281218_2.fastq.gz SRR8281219: - /mnt/zhao_trial/data/SRR8281219_1.fastq.gz - /mnt/zhao_trial/data/SRR8281219_2.fastq.gz SRR8281226: - /mnt/zhao_trial/data/SRR8281226_1.fastq.gz - /mnt/zhao_trial/data/SRR8281226_2.fastq.gz SRR8281236: - /mnt/zhao_trial/data/SRR8281236_1.fastq.gz - /mnt/zhao_trial/data/SRR8281236_2.fastq.gz SRR8281230: - /mnt/zhao_trial/data/SRR8281230_1.fastq.gz - /mnt/zhao_trial/data/SRR8281230_2.fastq.gz SRR8281233: - /mnt/zhao_trial/data/SRR8281233_1.fastq.gz - /mnt/zhao_trial/data/SRR8281233_2.fastq.gz SRR8281244: - /mnt/zhao_trial/data/SRR8281244_1.fastq.gz - /mnt/zhao_trial/data/SRR8281244_2.fastq.gz SRR8281245: - /mnt/zhao_trial/data/SRR8281245_1.fastq.gz - /mnt/zhao_trial/data/SRR8281245_2.fastq.gz SRR8281243: - /mnt/zhao_trial/data/SRR8281243_1.fastq.gz - /mnt/zhao_trial/data/SRR8281243_2.fastq.gz SRR8281251: - /mnt/zhao_trial/data/SRR8281251_1.fastq.gz - /mnt/zhao_trial/data/SRR8281251_2.fastq.gz SRR8281238: - /mnt/zhao_trial/data/SRR8281238_1.fastq.gz - /mnt/zhao_trial/data/SRR8281238_2.fastq.gz SRR8281250: - /mnt/zhao_trial/data/SRR8281250_1.fastq.gz - /mnt/zhao_trial/data/SRR8281250_2.fastq.gz execution.yaml Use execution.yaml to control which modules to run in RIMA. The preprocess module outputs are required for optional downstream analysis modules. Details of each module will be introduced in the next chapters. ##Note: The preprocess individual and cohort modules are necessary to obtain alignment and quality results. ##Run the remaining modules only after these two modules. preprocess_individual: true preprocess_cohort: true ##Optional modules ##Note: The below modules are specialized modules, each dealing with specific targets. ##Make sure to run both the individual and cohort parts of each module ##to get all results. ##Individual runs mutation_individual: false immune_response_individual: false immune_repertoire_individual: false microbiome_individual: false neoantigen_individual: false ##Cohort runs differential_expression_cohort: false immune_infiltration_cohort: false mutation_cohort: false immune_response_cohort: false immune_repertoire_cohort: false microbiome_cohort: false neoantigen_cohort: false ref.yaml The ref.yaml file provides the paths for all reference files. If you downloaded the pre-built reference files, you should not need to change the ref.yaml file. #REF.yaml - File to contain paths to static reference files that RNA-Seq requires # for its analysis. # NOTE: these are already pre-filled for hg38 # NOTE: organized by assemblies # # !VERY IMPORTANT: you can OVERRIDE any of these values in config.yaml! hg38: ###annotation path fasta_path: ./ref_files/GRCh38.d1.vd1.fa gtf_path: ./ref_files/gencode.annotation.gtf bed_path: ./ref_files/RSeQC_bed/refseqGenes.bed housekeeping_bed_path: ./ref_files/RSeQC_bed/housekeeping_refseqGenes.bed trust4_reper_path: ./ref_files/TRUST4/hg38_bcrtcr.fa trust4_IMGT_path: ./ref_files/TRUST4/human_IMGT+C.fa ###index path star_index: ./ref_files/star_index star_fusion_index: ./ref_files/fusion_index/ctat_genome_lib_build_dir salmon_index: ./ref_files/salmon_index/transcripts.fa msisensor_index: ./ref_files/msisensor_index/hg38/microsatellite.list centrifuge_index: ./ref_files/centrifuge_index/p_compressed+h+v annotation_pyprada: ./ref_files/pyPRADA/gencode.canonical.gene.exons.tab.txt ###tool path msisensor2_path: ./ref_files/msisensor2 trust4_path: ./ref_files/TRUST4 arcasHLA_path: ./ref_files/arcasHLA prada_path: ./ref_files/pyPRADA/pyPRADA_1.2 2.3.1 Video tutorial 2.4 Running RIMA Check the path of your conda env conda env list # conda environments: # base * /home/ubuntu/miniconda3 centrifuge_env /home/ubuntu/miniconda3/envs/centrifuge_env fusion_env /home/ubuntu/miniconda3/envs/fusion_env rnaseq /home/ubuntu/miniconda3/envs/rnaseq rseqc_env /home/ubuntu/miniconda3/envs/rseqc_env stat_perl_r /home/ubuntu/miniconda3/envs/stat_perl_r Check the pipeline with a dry run to ensure correct script and data usage. snakemake -s RIMA.snakefile -np Submit the job. Alignment and some of the other modules of RIMA will take several hours to run. It is recommended that you run RIMA in the background using a command such as nohup as below. nohup time snakemake -p -s RIMA.snakefile -j 4 &gt; RIMA.out &amp; note: Argument -j sets the cores for parallel runs (e.g. ‘-j 4’ can run 4 jobs in parallel at the same time.). Argument -p prints the command in each rule. Note: Here, output log records the run information. A user may run one module at a time to obtain a record of each module’s output log. 2.5 Output Output folders are generated in a folder called “analysis”. The output structure of each module will be introduced in the next chapters. "],["Preprocessing.html", "Chapter 3 Pre-processing of bulk RNA-seq data 3.1 Read Alignment 3.2 Quality Control 3.3 Gene quantification 3.4 Batch effect removal 3.5 Video demo of RIMA", " Chapter 3 Pre-processing of bulk RNA-seq data In this chapter, we will align RNA-seq data, check the data quality, quantify gene expression and handle batch effects across samples. To run the RIMA preprocess modules, in execution.yaml, set preprocess_individual and preprocess_cohort to true. The individual run of the preprocess module includes read alignment, quality checks and gene quantification. The cohort run of the preprocess module will merge data from all samples to produce cohort level reports for alignment, quality metrics and gene quantification. The cohort run will also conduct batch effect removal. ## execution.yaml ## preprocess_individual: true preprocess_cohort: true 3.1 Read Alignment Align reads with STAR STAR is one of the most common tools used for bulk RNA-seq data alignment to generate transcriptome BAM or genomic BAM output. The STAR code can be downloaded at here. A tutorial for STAR is available here. When using STAR, the first step is to create a genome index. In our RIMA pipeline, we downloaded the human genome (hg38) STAR index from Genomic Data Commons (GDC) . Let’s use sample SRR8281251 as an example. Example outputs folder structure RIMA runs STAR using the following command structure: STAR --runThreadN 4 --genomeDir ./ref_files/v22 --outReadsUnmapped None --chimSegmentMin 12 --chimJunctionOverhangMin 12 --chimOutJunctionFormat 1 --alignSJDBoverhangMin 10 --alignMatesGapMax 1000000 --alignIntronMax 1000000 --alignSJstitchMismatchNmax 5 -1 5 5 --outSAMstrandField intronMotif --outSAMunmapped Within --outSAMtype BAM Unsorted --readFilesIn {input} --chimMultimapScoreRange 10 --chimMultimapNmax 10 --chimNonchimScoreDropMin 10 --peOverlapNbasesMin 12 --peOverlapMMp 0.1 --genomeLoad NoSharedMemory --outSAMheaderHD @HD VN:1.4 --outFileNamePrefix {params.prefix} --quantMode TranscriptomeSAM RIMA renames the read aligment outputs according to sample id. analysis/star/SRR8281251/SRR8281251.sorted.bam analysis/star/SRR8281251/SRR8281251.transcriptome.bam analysis/star/SRR8281251/SRR8281251.Chimeric.out.junction analysis/star/SRR8281251/SRR8281251.Log.final.out RIMA also uses samtools to generate statistics from the alignment BAM file: samtools stats analysis/star/SRR828151/SRR8281251.sorted.bam | grep ^SN | cut -f 2- &gt; analysis/star/SRR8281251/SRR8281251.sorted.bam.stat.txt Merging the STAR alignment reports After the individual alignment runs of each sample, RIMA will merge the alignment reports from all samples to generate a file named STAR_Align_Report.csv. Below is an example of merged output: STAR,SRR8281218,SRR8281219,SRR8281226,SRR8281236,SRR8281230,SRR8281233,SRR8281244,SRR8281245,SRR8281243,SRR8281251,SRR8281238,SRR8281250 Number_of_input_reads,31058961,30244952,30144822,30214970,30219317,30294851,30233324,30188854,30267936,30155916,30238326,30205607 Average_input_read_length,200,200,200,200,200,200,200,200,200,200,200,200 Uniquely_mapped_reads_number,29396418,28842972,27785223,28625526,28552141,29084522,29172831,28527204,28611921,28526789,26648329,28820905 Uniquely_mapped_reads_%,94.65%,95.36%,92.17%,94.74%,94.48%,96.00%,96.49%,94.50%,94.53%,94.60%,88.13%,95.42% Average_mapped_length,198.82,198.69,198.65,198.64,198.64,198.54,198.64,198.54,198.66,198.64,198.71,198.62 Number_of_splices:_Total,14076881,16545751,18439209,15091999,14432943,15290737,16116559,18614840,14065847,13967615,9829323,14650425 Number_of_splices:_Annotated_(sjdb),14043726,16506835,18399706,15050436,14388389,15246382,16073843,18570667,14031241,13930154,9801357,14610503 Number_of_splices:_GT/AG,13944521,16380126,18275777,14941222,14287227,15142625,15961566,18425036,13939221,13836881,9738054,14508837 Number_of_splices:_GC/AG,106767,133082,130042,118569,116171,114096,121618,134112,97534,102169,69796,112736 Number_of_splices:_AT/AC,11811,14116,14898,13200,12486,11590,12575,12673,11867,11783,7031,13252 Number_of_splices:_Non-canonical,13782,18427,18492,19008,17059,22426,20800,43019,17225,16782,14442,15600 Mismatch_rate_per_base_%,0.20%,0.18%,0.17%,0.18%,0.19%,0.18%,0.17%,0.19%,0.19%,0.19%,0.18%,0.17% Deletion_rate_per_base,0.01%,0.00%,0.00%,0.01%,0.00%,0.01%,0.00%,0.00%,0.01%,0.01%,0.01%,0.00% Deletion_average_length,1.29,1.29,1.26,1.29,1.28,1.21,1.29,1.26,1.22,1.22,1.12,1.23 Insertion_rate_per_base,0.01%,0.01%,0.01%,0.01%,0.01%,0.01%,0.01%,0.01%,0.01%,0.01%,0.01%,0.01% Insertion_average_length,1.40,1.43,1.42,1.44,1.44,1.45,1.42,1.41,1.41,1.40,1.37,1.40 Number_of_reads_mapped_to_multiple_loci,1331220,1119545,2078090,1280274,1347073,901525,766599,1332933,1325151,1337251,3322861,1103343 %_of_reads_mapped_to_multiple_loci,4.29%,3.70%,6.89%,4.24%,4.46%,2.98%,2.54%,4.42%,4.38%,4.43%,10.99%,3.65% Number_of_reads_mapped_to_too_many_loci,9535,10773,11999,12262,15652,9758,8344,10240,8594,10179,9217,8381 %_of_reads_mapped_to_too_many_loci,0.03%,0.04%,0.04%,0.04%,0.05%,0.03%,0.03%,0.03%,0.03%,0.03%,0.03%,0.03% %_of_reads_unmapped:_too_many_mismatches,0.08%,0.09%,0.12%,0.13%,0.13%,0.14%,0.10%,0.24%,0.13%,0.12%,0.11%,0.09% %_of_reads_unmapped:_too_short,0.92%,0.76%,0.73%,0.81%,0.83%,0.81%,0.80%,0.77%,0.90%,0.77%,0.70%,0.78% %_of_reads_unmapped:_other,0.04%,0.04%,0.05%,0.04%,0.05%,0.03%,0.04%,0.04%,0.03%,0.05%,0.04%,0.04% Number_of_chimeric_reads,592271,594198,549596,631747,635307,717293,631225,666748,637640,622475,600743,636839 %_of_chimeric_reads,1.91%,1.96%,1.82%,2.09%,2.10%,2.37%,2.09%,2.21%,2.11%,2.06%,1.99%,2.11% 3.2 Quality Control Downsampling alignment BAMs RseQC is a standard tool for checking the quality of read alignments, providing the principal measurements of RNA-seq data quality. An RseQC tutorial is available here. To reduce running time, we first sub-sample sorted BAM files to be used by RseQC to assess alignment quality. If the config.yaml parameter ‘rseqc_ref’ is set to ‘house_keeping’, RIMA will extract alignments of house keeping genes for the sub-sample. ## Example of subsampling 50% of input alignments samtools view -s 0.5 -b analysis/star/SRR8281218/SRR8281218.sorted.bam &gt; analysis/star/SRR8281218/SRR8281218_downsampling.bam # Extract the alignment of housekeeping genes. bedtools intersect -a analysis/star/SRR8281218/SRR8281218_downsampling.bam -b ./ref_files/housekeeping_refseqGenes.bed &gt; analysis/star/SRR8281218/SRR8281218_downsampling_housekeeping.bam # index BAM samtools index analysis/star/SRR8281218/SRR8281218_downsampling_housekeeping.bam &gt; analysis/star/SRR8281218/SRR8281218_downsampling_housekeeping.bam.bai RseQC Quality metrics Transcript integrity number (TIN) is the most widely used measure of RNA integrity, which is the percentage of transcripts that have uniform read coverage across the genome. RseQC calculates the TIN of each transcript and reports mean TIN, median TIN and standard deviation for all transcripts in a sample. The median TIN score (medTIN) across all transcripts is commonly used to indicate the RNA integrity of each sample. Read distribution summarizes the fraction of reads aligned into different genomic regions, such as exon and intron regions. Gene body coverage shows the RNA-seq read coverage over the gene body. Low quality samples have low alignment fractions, low integrity (median TIN) and/or abnormal read distributions and should be removed in downstream analysis. Merge quality metrics RIMA will also merge quality metrics for all samples. Below are examples of the merged outputs for TIN score tin_score_summary.txt and read distribution read_distrib.matrix.tab: ##tin_score_summary.txt## Bam_file TIN(mean) TIN(median) TIN(stdev) SRR8281218_downsampling_housekeeping.bam 72.59011823410742 76.61544321066245 15.70457852012789 SRR8281219_downsampling_housekeeping.bam 74.53459359515176 78.36139111185804 14.862696392336295 SRR8281226_downsampling_housekeeping.bam 72.12569765806015 76.04482057429738 15.150628049210777 SRR8281236_downsampling_housekeeping.bam 75.10959004809101 79.0211107295296 14.112536675463657 SRR8281230_downsampling_housekeeping.bam 74.95210786264646 78.18898561188249 14.084506430648968 SRR8281233_downsampling_housekeeping.bam 71.91235332638948 76.36385765230236 16.193874225558574 SRR8281244_downsampling_housekeeping.bam 72.42514699067206 76.9844608754321 16.270160903196263 SRR8281245_downsampling_housekeeping.bam 72.16726184355547 76.41674529483181 15.380595156507917 SRR8281243_downsampling_housekeeping.bam 71.56229409539716 74.7019940049169 13.711275796768888 SRR8281251_downsampling_housekeeping.bam 73.02855865353006 77.30010010150008 14.902687257461483 SRR8281238_downsampling_housekeeping.bam 66.23444336304713 70.08838336433544 17.437545601110816 SRR8281250_downsampling_housekeeping.bam 75.25874145796432 78.83524471249612 14.125154826821316 ##read_distrib.matrix.tab## Feature SRR8281218 SRR8281219 SRR8281226 SRR8281236 SRR8281230 SRR8281233 SRR8281244 SRR8281245 SRR8281243 SRR8281251 SRR82 81238 SRR8281250 TES_down_1kb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 TSS_up_1kb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 TSS_up_5kb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Introns 0.05 0.05 0.03 0.06 0.08 0.06 0.05 0.04 0.04 0.04 0.04 0.04 TES_down_5kb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 CDS_Exons 0.80 0.81 0.85 0.79 0.77 0.79 0.79 0.83 0.80 0.80 0.81 0.80 3&#39;UTR_Exons 0.12 0.11 0.08 0.12 0.11 0.12 0.11 0.09 0.12 0.11 0.11 0.12 TES_down_10kb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 5&#39;UTR_Exons 0.04 0.04 0.04 0.03 0.03 0.03 0.04 0.04 0.03 0.04 0.04 0.04 TSS_up_10kb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 In addition to individual gene body coverage plots, a cohort level gene body coverage plot is generated. Below is an example of geneBodyCoverage.curves.png: Figure 3.1: Gene Body Coverage Curves 3.3 Gene quantification After the alignment of sequencing reads and quality checks, we quantify the gene or transcript expression from the BAM files. Both Salmon and RSEM are widely used for gene quantification. Salmon conducts fast transcript-level quantification, and RSEM performs both gene-level and transcript-level quantification. Salmon is usually faster and less memory-consuming than RSEM. RSEM generates transcripts per million (TPM), reads per kilobase of exon model (transcript) per million mapped reads (RPKM) and fragments per kilobase of exon model (transcript) per million mapped reads (FPKM) expression. Salmon provides TPMs as a part of its output. All three measures (TPM, RPKM, FPKM) are normalization methods that account for both sequencing depth and gene lengths. (Longer transcripts will typically have more reads.) TPM is currently thought to be the best method to normalize gene counts. HTSeq quantifies gene expression according to mapped read counts. Both normalized gene expression and raw read counts can be used for differential expression analysis. Example output folder structure RIMA uses Salmon for gene quantification. The transcriptome alignment result from STAR is used as the Salmon input: salmon quant -t ./ref_files/salmon_gdc_index/gencode.v22.ts.fa -l A -a analysis/star/SRR8281218/SRR8281218.transcriptome.bam -o analysis/salmon/SRR8281218 The following is an example of an output file from Salmon Name Length EffectiveLength TPM NumReads ENST00000456328.2 1657 1474.085 0.000000 0.000 ENST00000450305.2 632 449.595 0.000000 0.000 ENST00000488147.1 1351 1168.085 7.412619 139.959 ENST00000619216.1 68 69.000 0.000000 0.000 ENST00000473358.1 712 529.382 0.000000 0.000 ENST00000469289.1 535 353.431 0.000000 0.000 ENST00000607096.1 138 16.202 0.000000 0.000 RIMA then uses ‘tximport’ from the DESeq2 R package to combine a cohort’s gene level TPMs into a summary file: ## First 10 rows of merge TPMs ## SRR8281218,SRR8281219,SRR8281226,SRR8281236,SRR8281233,SRR8281230,SRR8281244,SRR8281245,SRR8281243,SRR8281238,SRR8281251,SRR8281250 5_8S_rRNA,0,0,0,0,0,0,0,0,0,0,0,0 5S_rRNA,0,0,0,0,0,0,0,0,0,0,0,0 7SK,0,0.75,1,5.864,5.667,5,1.961,2.67,10.47,3.531,5,2.981 A1BG,98.378,248.265,222.032,106.318,159.868,262.034,210.18,157.196,83.865,137.558,130.693,193.207 A1BG-AS1,82.273,252.763,70.572,80.758,100.73,297.316,119.662,145.835,66.107,59.74,90.452,168.508 A1CF,2,2,0,3,0,0,0,0,1,2,1,196 A2M,14326.273,9018.603,27465.295,22061.332,31646.181,4559.962,14865.119,20065.994,30592.578,19598.148,12355.795,7203.953 A2M-AS1,59.728,6.397,12.704,36.667,52.819,4.038,24.881,13.006,34.423,23.852,6.206,25.047 A2ML1,180.001,0,17,42,83,55,93,0,12,10,9,763.998 A2ML1-AS1,0,0,0,0,0,0,0,0,0,3.506,0,0 3.4 Batch effect removal Batch effects across samples are easily overlooked but worth considering for immunotherapy cohort studies. Batch effects are usually caused by unbalanced experimental design and confound the estimation of group differences. For example, samples processed at different facilities may have sequencing differences that are not due to actual biological differences in the samples themselves. To avoid confounding actual biological variation with the effects of experimental design, limma and ComBat are common approaches to correct batch effects. Limma uses a two-way ANOVA approach. ComBat uses an empirical Bayes approach, which is critical for small batches to avoid over-correction. For large batches, both methods should be similar. The sva R package implements both ComBat and surrogate variable analysis (sva) for batch effect correction. Principal components analysis (PCA) or unsupervised clustering before and after batch effect removal is an excellent way to validate that a batch effect has been removed. To evaluate if your samples have a batch effect, RIMA will generate PCA plots of gene expression data before and after batch effect removal by limma. To utilize this feature, modify the “batch” parameter in the config.yaml file for your run. An example of PCA before and after batch correction using limma is below. (Note: No batch effect was found in the original data used for this tutorial. To generate this diagram, we added a ‘syn_batch’ column to the metasheet for demonstration purposes.) Example output folder structure Example output PCA figures Figure 3.2: Before(left) and after(right) batch correction with Limma 3.4.1 Start with TPM matrix RIMA’s batch_removal.R contains the R scripts for batch effect removal using the TPM matrix (the cohort level TPM summary file) and metasheet as inputs. Rscript src/preprocess/batch_removal.R -e {exprsn} -c {covariates} -d {sample_column} -m {meta} -b {before} -a {after} Usage: -e input expression matrix without log transformation [Required] -c batch covariates -d column name from metasheet that indicated included samples -m metasheet -b Output file name before batch effect removal -a Output file name after batch effect removal Users will receive a log transformed TPM matrix with batch effect removed after running the above scripts. RIMA’s pca.R generates PCA plots before and after batch effects. Rscript src/preprocess/pca.R -b {before} -a {after} -m {meta} -c {covariates} -g {design} -i {output_before} -j {output_after} Usage: -b expression matrix before batch removal -a expression matrix after batch removal -m metasheet -c batch covariates -g column name from metasheet that indicated included samples -i Output plot name before batch removal -j Output plot name before after removal 3.5 Video demo of RIMA "],["Differential.html", "Chapter 4 Differential gene analysis 4.1 Differential gene expression using DESeq2 4.2 Different gene expression analysis 4.3 Gene set enrichment analysis (GSEA) 4.4 Single sample gene set enrichment analysis (ssGSEA)", " Chapter 4 Differential gene analysis Once you obtain gene counts from the preprocessing modules of RIMA, you can compare gene expression levels for different sample phenotypes. For example, you may wish to know which genes are differentially expressed between patients who respond and do not respond to a particular treatment. In addition, you may wish to know if particular gene sets are enriched in expression between different phenotypes. These gene sets may be associated with a known biological pathway, process or molecular function. The differential gene analysis module of RIMA allows you to perform these comparisons. 4.1 Differential gene expression using DESeq2 DESeq2 is a commonly used package that provides methods for comparison of gene expression levels. The package is described in: Love, M.I., Huber, W., Anders, S. (2014) Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biology, 15:550. 10.1186/s13059-014-0550-8 Details about how to run DeSeq2 are also included in the DESeq2 vignette. 4.1.1 Inputs of DESeq2 DESeq2 accepts four kinds of inputs: 1) transcript abundance files; 2) a read count matrix; 3) htseq-count files or 4) a SummarizedExperiment object. Tximport is a tool that can import gene quantification data generated by Salmon (quant.sf) and convert the data into a gene-level abundance format that DESeq2 can use. RIMA generated quant.sf files during the preprocessing module. As a part of using tximport, Ensemble transcript IDs are converted into gene names. RIMA contains a tx2gene.csv file with transcript IDs and gene names as below: ID,GENENAME ENST00000000233.8,ARF5 ENST00000000412.6,M6PR ENST00000000442.9,ESRRA ENST00000001008.5,FKBP4 ENST00000001146.5,CYP26B1 ENST00000002125.7,NDUFAF7 ENST00000002165.9,FUCA2 ENST00000002501.9,DBNDD1 ENST00000002596.5,HS3ST1 Tximport uses the quant.sf files generated by Salmon and the tx2gene.csv file to generate matrices as described in DESeq2: ### filelist is a list of quant.sf files generated by Salmon gene quantification. txi &lt;- tximport(filelist, type=Salmon, tx2gene=tx2gene) 4.2 Different gene expression analysis After creating the transcript abundance file, we are ready to find differentially expressed genes between your selected conditions. If you have identified a batch effect in your earlier analysis, DESeq2 can be run to account for this batch effect. We will first describe how to run DESeq2 without a batch effect. We will then describe how to run DESeq2 when a batch effect exists. 4.2.1 Running DESeq2 without batch effect We will run DESeq2 to determine differential expression for a particular phenotype. In our case, we are interested in the genes that are differentially expressed between responders and non-responders. For this example, the Group column in the metasheet.csv has been set up with “R”, “NR” or “NA” as shown in Chapter 2.3 and the config.yaml file is set up with the “batch” parameter set to false; “design” set to Group “Treatment” set to R “Control” set to NR as seen in Chapter 2.3. This results in a DESeq call like the following: ddsTxi &lt;- DESeqDataSetFromTximport(txi, colData = samples, design = ~ Group) dds &lt;- DESeq(ddsTxi) 4.2.2 Running DESeq2 with batch effect DESeq2 can account for any batch effect by providing the batch variable as a covariate. If your batch effect analysis from the preprocessing module indicated that there is a batch effect in your samples, set the “batch” field in config.yaml to the appropriate column name in your metasheet. #########Cohort level analysis parameters################ design: Group # Condition on which to do comparsion (as set up in metasheet.csv) Treatment: R # Treatment use in DESeq2, corresponding to positive log fold change Control: NR # Control use in DESeq2, corresponding to negative log fold change batch: syn_batch # Options: &#39;false&#39; or a column name from the metasheet.csv. We use the information in “batch” for DESeq2 in the following manner, where “syn_batch” is the column designated in the config.yaml file: ddsTxi &lt;- DESeqDataSetFromTximport(txi, colData = samples, design = ~ syn_batch + Group) dds &lt;- DESeq(ddsTxi) 4.2.3 Output from DESeq2 DESeq2 output includes values for baseMean, log2FoldChange, lfcSE, stat, pvalue, padj. These fields have the following meanings: baseMean = the average of the normalized counts for all samples Log2FoldChange = log base 2 fold changes for the condition tested. For example if the file is Responder_responder_VS_nonresponder_DESqe2_raw.txt, Log2FoldChange will be the estimated logarithmic fold change log2(responder/nonresponder). lfcSE = Log2FoldChange Standard Error stat= Wald statistic pvalue = Wald test p value for the Log2FoldChange estimate padj. = FDR adjusted p value (Benjamini-Hochberg adjusted p value) {comparison condition}_DEseq2_raw.txt lists Gene names directly from the DESeq2 output. It also contains a value for -log10(padj). 4.2.4 Volcano Plot(s) Volcano plots are often used to visualize the results of differential expression analysis. The x axis represents the log2FC, and the y axis represent the -log10(P.value). Up-regulated genes have positive log2FCs and down-regulated genes have negative log2FCs. Below is an example of a volcano plot from the previous differential expression analysis. Genes that meet the following criteria are labeled: FDR &lt; 0.05 absolute Log2FoldChange &gt; 1 Figure 4.1: Volcano plot 4.3 Gene set enrichment analysis (GSEA) GSEA was developed by UC San Diego and the Broad Institute. It is described in Subramanian, Tamayo, et al. (2005, PNAS 102, 15545-15550) and Mootha, Lindgren, et al. (2003, Nat Genet 34, 267-273). Gene Set Enrichment Analysis can be used to detect patterns in differential expression that affect particular gene pathways, molecular functions, cellular components or processes. RIMA uses the clusterProfile R package to look for enrichment in the following gene sets: KEGG canonical pathways Gene Ontology – including Biological Process (BP), Cellular Component (CC) and Molecular Function (MF). MSigDB Hallmark gene sets RIMA uses a ranked list of DESeq2 outputs. Ranking is based on the following: sign(data$log2FoldChange) * (-log10(data$pvalue)) GSEA output is reported in both text and figure outputs: Example output folder structure Each of these tab separated files contains the following information: ID = ID of the gene set Description = description of the gene set setSize = number of genes in the gene set after filtering out genes not in the expression data. enrichmentScore = the degree to which the gene set is enriched in the top or bottom of the ranked set of genes. NES = normalized gene enrichment score. pvalue = nominal p value p.adjust = adjusted p value; RIMA sets pAdjustMethod to ‘BH’ (Bejamini Hochberg) when running clusterProfiler qvalues = q value (FDR as implemented by GSEA) rank = the position in the ranked list at which the maximal enrichment score was achieved. leading_edge = 3 statistics (tags, list and signal) on the subset of genes that most influence the enrichment score core_enrichment group = the subset of genes that contribute most to the enrichment score. significance = a representation of the p.adjust value using stars. One star is set for p.adjust &lt;0.1, two stars &lt;0.5 and three stars &lt; 0.01. Please see the clusterProfile tutorial for more information about these values. Below is an example of the figure output for GSEA using the Hallmark genesets. Example GSEA figure output Figure 4.2: Hallmark gene set enrichment output 4.4 Single sample gene set enrichment analysis (ssGSEA) ssGSEA is a different method of trying to find enriched pathways in your dataset. GSEA uses the differential expression patterns of all samples to generate enrichment scores based on phenotypic differences. In contrast, ssGSEA generates enrichment scores for each sample. The ssGSEA results can then be used to look for outliers in your dataset or to compare enriched pathways among samples. Please see ssGSEA for more information. The inputs to ssGSEA are log2 transformed tpms with batch effects removed if needed. RIMA provides ssgsea results for the KEGG and Hallmark gene sets. "],["Repertoire.html", "Chapter 5 Immune repertoire 5.1 TRUST4 5.2 Cluster calculation 5.3 Clonotypes per kilo-reads (CPK) 5.4 TCR and BCR entropy and Clonality 5.5 Fraction of reads mapped to TCR and BCR 5.6 Somatic hypermutation rate of BCR 5.7 Ig isotype frequency 5.8 Cohort analysis", " Chapter 5 Immune repertoire A key part of immune specific analysis is assessing the nature of the T and B cells that make up the tumor microenvironment. This assessment includes, but is not limited to, measures such as receptor diversity and clonality. Once tumors are infiltrated with T cells and B cells, the T cells and B cells are activated if their receptors – TCRs and BCRs, respectively – recognize and bind to tumor-associated antigens. TCRs and BCRs are highly diverse to allow different T and B cells to recognize different pathogens or tumor-associated antigens. Part of the diversity of TCRs and BCRs is due to V(D)J recombination which mixes and matches different V, D and J segments of the genome in order to produce a wide variety of receptors. Complementary-determining region 3 (CDR3) is a highly variable region of both TCRs and BCRs that is central to the antigen binding site of these receptors. V(D)J junctional sequence assembly is a major source of TCR/BCR CDR3 diversity. Immune repertoire profiling (characterizing the CDR3 sequences of TCRs and BCRs in a tumor sample) is essential for quantifying T/B cell diversity and clonality. These measures, in turn, are important tumor immune characteristics and key indicators of immunotherapy response. Currently, newly-emerging immune sequencing techniques, such as TCR-seq and BCR-seq, have been designed to sequence T and B cell receptors through quantitative PCR (qPCR). However, TCR-seq and BCR-seq are costly and not always available for particular datasets. To overcome this difficulty, Tcr Receptor Utilities for Solid Tissue (TRUST) has been developed to infer the immune repertoire from bulk RNA-seq reads. V(D)J recombination results in sequences that do not align to genome references. TRUST combines reads that align to the V, D or J regions of the reference genome with sequences that do not align to the host genome to infer de novo assembled CDR3 sequences. TRUST provides an overview of the immune repertoire of tumors, including CDR3 sequence length and the frequency of various V genes, J genes, and VJ pairs for different chains in the TCR and BCR. For cohort analysis, some basic metrics for TCRs and BCRs across samples could be computed to relate immune repertoire characteristics to specific phenotypes, including the fraction of reads mapped to TCR/BCR, the number of TCR/BCR unique clonotypes of CDR3 sequences, TCR/BCR diversity, and clonality. Since activated B cells undergo somatic hyper-mutation, antibody production, and Immunoglobulin (Ig) class switches during B cell maturation, TRUST also calculates the somatic hypermutation (SHM) rate for BCRs. In addition, TRUST predicts Ig isotypes for BCRs, which allows for quantification of the Ig compositions representing different maturation statuses (IGHM, IGHD, IGHG3, IGHG1, IGHA1, IGHG2, IGHG4, IGHA2, IGHE) and generation of an Ig class switches network. Taken together, the immune repertoire analysis quantifies the T/B cell population at both the individual and cohort levels, enabling one to characterize dynamic evolution in the TME via the diversity and clonal expansion of tumor-infiltrating T cells or B cells. RIMA currently uses the fourth version of TRUST, TRUST4. 5.1 TRUST4 Example Command: ./run-trust4 -b example.bam -f hg38_bcrtcr.fa --ref human_IMGT+C.fa The above command utilizes hg3_bcrtcr.fa (a fasta file containing the coordinates and sequences of V/D/J/C genes) and human_IMGT+C.fa (a V/D/J/C gene reference file from the IMGT database), and produces a simple report (example_report.tsv). This report contains a list of assembled clonotypes from example.bam with the following fields: “read_count, frequency(proportion of read_count), CDR3_dna, CDR3_amino_acids, V, D, J, C, consensus_id, consensus_id_full_length”. These fields contain the abundance, CDR3 sequence (nucleotides and amino acids), gene segment usage and identifier for each clonotype. 5.1.1 TRUST4 output In the example codes below, we use one sample to illustrate how RIMA processes the results from TRUST4. RIMA directly adds the sample ID to the TRUST4 output file. This step makes it easier to combine all of individual sample results in the subsequent analysis. We provided the customized trust4_metric_functions.R in our pipeline repo to illustrate how BCR clusters, TCR and BCR clonality, BCR somatic hypermutation rate and BCR isotype class switching are calculated. Example individual outputs for sample ‘SRR8281233’ are included in each section below. Example output folder structure 5.2 Cluster calculation Activation of B cells leads to somatic hypermutation (SHM). As B cells proliferate, random mutations are generated at a high rate in the V-region sequence. Favorable mutations lead to better antigen binding and are selected for survival as the B cells continue to proliferate. BCR clustering is used to identify BCRs from the same lineage. The clusters can then be used to estimate somatic hypermutation rate (described later in this chapter). library(dplyr) #load processed function source(&quot;TRUST4/trust4_metric_functions.R&quot;) # read the individual sample result from RIMA cdr3 &lt;- read.table(file = &quot;TRUST4/SRR8281233_cdr3.out.processed.txt&quot;, sep = &quot;\\t&quot;, header = TRUE, stringsAsFactors = FALSE) #filter out count of cdr ==0 and add the phenotype info for downstream comparison #This SRR8281233 smaple is Non-responder phenotype &lt;- &quot;NR&quot; cdr3 &lt;- subset(cdr3, count &gt; 0) %&gt;% mutate(V = as.character(V), J = as.character(J), C = as.character(C), CDR3aa = as.character(CDR3aa)) %&gt;% mutate(clinic = as.character(phenotype)) head(cdr3) ## count frequency CDR3nt ## 1 125 0.03682734 TGCATGCAAGCTCTACAAACTCCGTACACTTTT ## 2 124 0.03654850 TGTCAGCAGCGTAGCAACTGGCCTTGGACGTTC ## 3 98 0.05410145 TGTGCGATGGGGGATAGTAGTGGCTGGTACCGTCCTCCCGACTCCTGG ## 4 97 0.02847096 TGTCAACATTACGGTACCTCGTGGACGTTC ## 5 79 0.02320237 TGTCAGCAGCGTAGCAACTGGCCGCTCACTTTC ## 6 78 0.02289418 TGCATGCAGCGTGTGAGTCTTCCCCACACTTTT ## CDR3aa V D J C cid ## 1 CMQALQTPYTF IGKV2-28*01 . IGKJ2*01 IGKC assemble0 ## 2 CQQRSNWPWTF IGKV3-11*01 . IGKJ1*01 IGKC assemble1701 ## 3 CAMGDSSGWYRPPDSW IGHV3-33*01 IGHD6-19*01 IGHJ5*01 IGHG1 assemble1 ## 4 CQHYGTSWTF IGKV3-20*01 . IGKJ1*01 IGKC assemble1713 ## 5 CQQRSNWPLTF IGKV3-11*01 . IGKJ4*01 IGKC assemble1717 ## 6 CMQRVSLPHTF IGKV2-40*01 . IGKJ2*01 IGKC assemble1719 ## sample clinic ## 1 SRR8281233 NR ## 2 SRR8281233 NR ## 3 SRR8281233 NR ## 4 SRR8281233 NR ## 5 SRR8281233 NR ## 6 SRR8281233 NR #determine whether the cdr animo acid is complete or partial cdr3$is_complete &lt;- sapply(cdr3$CDR3aa, function(x) ifelse(x != &quot;partial&quot; &amp;&amp; x != &quot;out_of_frame&quot; &amp;&amp; !grepl(&quot;^_&quot;,x) &amp;&amp; !grepl(&quot;^\\\\?&quot;, x),&quot;Y&quot;,&quot;N&quot;)) #exact the TCR and BCR cdr3.bcr &lt;- subset(cdr3, grepl(&quot;^IG&quot;,V) | grepl(&quot;^IG&quot;,J) | grepl(&quot;^IG&quot;,C)) cdr3.tcr &lt;- subset(cdr3, grepl(&quot;^TR&quot;,V) | grepl(&quot;^TR&quot;,J) | grepl(&quot;^TR&quot;,C)) #add lib size and clinic traits cdr3.bcr &lt;- cdr3.bcr %&gt;% mutate(lib.size = sum(count)) cdr3.tcr &lt;- cdr3.tcr %&gt;% mutate(lib.size = sum(count)) #split BCR into heavy chain and light chain cdr3.bcr.heavy &lt;- subset(cdr3.bcr, grepl(&quot;^IGH&quot;,V) | grepl(&quot;^IGH&quot;,J) | grepl(&quot;^IGH&quot;,C)) cdr3.bcr.light &lt;- subset(cdr3.bcr, grepl(&quot;^IG[K|L]&quot;,V) | grepl(&quot;^IG[K|L]&quot;,J) | grepl(&quot;^IG[K|L]&quot;,C)) #save BCR and TCR info for downsteam use outdir &lt;- &quot;TRUST4/individual/&quot; sample &lt;- &quot;SRR8281233&quot; save(cdr3.bcr.light, file = paste(outdir, &quot;TRUST4_BCR_light.Rdata&quot;,sep = &quot;&quot;)) save(cdr3.bcr.heavy, file = paste(outdir, &quot;TRUST4_BCR_heavy.Rdata&quot;,sep = &quot;&quot;)) save(cdr3.tcr, file = paste(outdir, &quot;TRUST4_TCR.Rdata&quot;,sep = &quot;&quot;)) #BCR clustering #Note that not every sample have BCR cluster sample_bcr_cluster &lt;- BuildBCRlineage(sampleID = sample, Bdata = cdr3.bcr.heavy, start=3, end=10) ## use default substitution matrix ## use default substitution matrix ## use default substitution matrix save(sample_bcr_cluster,file = paste(outdir, sample,&quot;_TRUST4_BCR_heavy_cluster.Rdata&quot;, sep = &quot;&quot;)) attributes(sample_bcr_cluster) ## $names ## [1] &quot;RGSPRFID&quot; &quot;KVPGRRTR&quot; &quot;RNLYYGAY&quot; head(sample_bcr_cluster$RGSPRFID) ## $distMat ## [,1] [,2] [,3] [,4] ## [1,] 0 1 1 3 ## [2,] 0 0 2 4 ## [3,] 0 0 0 2 ## [4,] 0 0 0 0 ## ## $Sequences ## [1] &quot;TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG&quot; ## [2] &quot;TGTGCGCGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG&quot; ## [3] &quot;TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCTGG&quot; ## [4] &quot;TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCCAG&quot; ## ## $data ## count frequency CDR3nt ## 1 2 0.001099511 TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG ## 2 2 0.001099511 TGTGCGCGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG ## 3 7 0.003848289 TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCTGG ## 4 2 0.001099511 TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCCAG ## CDR3aa V D J C cid ## 1 CARGSPRFIDYGGSLHFW IGHV4-31*01 IGHD4-23*01 IGHJ4*02 IGHG1 assemble836 ## 2 CARGSPRFIDYGGSLHFW IGHV4-31*11 IGHD4-23*01 IGHJ4*02 IGHG1 assemble90 ## 3 CARGSPRFIDYGGSFHFW IGHV4-31*11 IGHD4-23*01 IGHJ4*02 IGHG1 assemble90 ## 4 CARGSPRFIDYGGSFHFQ IGHV4-31*11 IGHD4-23*01 IGHJ4*02 IGHG1 assemble90 ## sample clinic is_complete lib.size ## 1 SRR8281233 NR Y 5184 ## 2 SRR8281233 NR Y 5184 ## 3 SRR8281233 NR Y 5184 ## 4 SRR8281233 NR Y 5184 5.3 Clonotypes per kilo-reads (CPK) CPK can be calculated by taking the number of unique CDR3 calls for a chain divided by the total number of reads for that chain, with this result being multiplied by 1000. This is used as a measure of clonotype diversity. #TCR CPK cpk &lt;- aggregate(CDR3aa ~ sample+clinic+lib.size, cdr3.tcr, function(x) length(unique(x))) %&gt;% mutate(CPK = signif(CDR3aa/(lib.size/1000),4)) cpk ## sample clinic lib.size CDR3aa CPK ## 1 SRR8281233 NR 73 20 274 5.4 TCR and BCR entropy and Clonality The Shannon entropy index is a measure used for repertoire diversity using clonotype frequencies, which reflects both richness and evenness of the repertoire. This measure informs us of the probability that two random selections from the same repertoire would represent the same clonotype. Clonality can be measured using normalized entropy over the number of unique clones (1-shannon entropy/log(N), where N is the number of unique clones). It is equivalent to 1 - Pielou’s Evenness, making it inversely proportional to diversity. A higher clonality index indicates an uneven repertoire due to expansion of clones. #BCR clonality and entropy sample &lt;- &quot;SRR8281233&quot; single_sample_bcr_clonality &lt;- getClonality(sample, cdr3.bcr.heavy, start=3, end=10) ## use default substitution matrix ## use default substitution matrix ## use default substitution matrix ## [1] &quot;SRR8281233&quot; single_sample_bcr_clonality[1:3] ## sample clonality entropy ## &quot;SRR8281233&quot; &quot;0.0899083128267854&quot; &quot;6.83997594611138&quot; #TCR clonality and entropy sample &lt;- &quot;SRR8281233&quot; single_sample_tcr_clonality &lt;- getClonalityTCR(sample,cdr3.tcr) single_sample_tcr_clonality ## sample clonality entropy ## &quot;SRR8281233&quot; &quot;0.0699534783052342&quot; &quot;4.0850595412347&quot; 5.5 Fraction of reads mapped to TCR and BCR The fraction of reads mapped to TCR and BCR can be used as a rough approximation of T and B cell infiltration. The fraction of all reads that are mapped to either TCR or BCR is indicated by the V,D,J-gene prefixes of the clonotypes identified by TRUST4. The fraction is composed of the proportion of reads with genes prefixed by “TR” (TCR) and genes prefixed by “IG” (BCR) divided by the total of all mapped genes in the sample. #exact the mapped reads info from alignment index file sample &lt;- &quot;SRR8281233&quot; file &lt;- read.table(&quot;TRUST4/SRR8281233.sorted.bam.stat.txt&quot;,sep = &quot;\\t&quot;,row.names = 1) mapped.reads &lt;- file[&quot;reads mapped:&quot;,&quot;V2&quot;] individual.stats &lt;- cbind.data.frame(sample = sample, map.reads = mapped.reads) #---------fraction of BCR reads------------------ ##extract library size lib.size &lt;- cdr3.bcr.heavy %&gt;% group_by(sample) %&gt;% dplyr::summarise(lib = mean(lib.size)) ##combine stats and library size bcr.lib.reads &lt;- merge(individual.stats,lib.size,by = &quot;sample&quot;) %&gt;% mutate(Infil = signif(as.numeric(lib)/as.numeric(map.reads),4)) #------------fraction of TCR reads----------------- ##extract library size lib.size &lt;- cdr3.tcr %&gt;% group_by(sample) %&gt;% dplyr::summarise(lib = mean(lib.size)) ##combine stats and library size tcr.lib.reads &lt;- merge(individual.stats,lib.size,by = &quot;sample&quot;) %&gt;% mutate(Infil = signif(as.numeric(lib)/as.numeric(map.reads),4)) combined &lt;- rbind(bcr.lib.reads, tcr.lib.reads) %&gt;% mutate(Type = c(&quot;BCR&quot;, &quot;TCR&quot;)) combined ## sample map.reads lib Infil Type ## 1 SRR8281233 59972094 5184 8.644e-05 BCR ## 2 SRR8281233 59972094 73 1.217e-06 TCR 5.6 Somatic hypermutation rate of BCR As described in the BCR clustering section of this chapter, somatic hypermutation (SHM) introduces more variation in a particular BCR and occurs when mature B cells are activated and proliferate. For each BCR cluster identified by TRUST4, TRUST4 calculates the number of point mutations in the nucleotide sequences in order to estimate SHM. SHM can be used as an approximation of B cell activity within a sample. SHM.ratio &lt;- getSHMratio(sample_bcr_cluster) ## [1] 54 ## [1] 2 ## [1] 48 ## [1] 3 ## [1] 51 ## [1] 1 5.7 Ig isotype frequency The immunoglobulin heavy (IGH) locus includes the constant heavy (IGHC) gene segment. This gene segment includes different isotypes (IGHA1, IGHA2, IGHD, IGHE, IGHG1, IGHG2, IGHG3, IGHG4, IGHM) and the proportion of the abundance of these different segments indicates the isotype frequency. The isotype frequency can be found by isolating reads with genes prefixed “IGH” and comparing the occurrence of different isotypes in the C_gene column. #This SRR8281233 sample is Non-responder phenotype &lt;- &quot;NR&quot; st.Ig &lt;- cdr3.bcr.heavy %&gt;% group_by(clinic,sample) %&gt;% mutate(est_clonal_exp_norm = frequency/sum(frequency)) %&gt;% #as.numeric(sample.clones[filename,2]) dplyr::filter(C != &quot;*&quot; &amp; C !=&quot;.&quot;) %&gt;% group_by(sample, C) %&gt;% dplyr::summarise(Num.Ig = sum(est_clonal_exp_norm)) %&gt;% mutate(clinic = phenotype) ## `summarise()` has grouped output by &#39;sample&#39;. You can override using the `.groups` argument. st.Ig ## # A tibble: 8 x 4 ## # Groups: sample [1] ## sample C Num.Ig clinic ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 SRR8281233 IGHA1 0.134 NR ## 2 SRR8281233 IGHA2 0.0682 NR ## 3 SRR8281233 IGHD 0.00385 NR ## 4 SRR8281233 IGHG1 0.542 NR ## 5 SRR8281233 IGHG2 0.0704 NR ## 6 SRR8281233 IGHG3 0.0280 NR ## 7 SRR8281233 IGHG4 0.0126 NR ## 8 SRR8281233 IGHM 0.0407 NR 5.8 Cohort analysis The examples above demonstrate the basic immune repertoire-related metrics using a single sample. In the cohort analysis, all of samples are combined in order to facilitate comparisons within a particular phenotype. The phenotype used for comparison is the one identified in the config.yaml cohort parameter section. This section is described in more detail in Chapter 4.2.1. . #load the pre-processed results that contain all samples #These results would be automatically generated after running the RIMA immune repertoire module inputdir &lt;- &quot;TRUST4/Cohort/&quot; load(paste(inputdir,&quot;TRUST4_BCR_heavy_cluster.Rdata&quot;, sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_clonality.Rdata&quot;, sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_SHMRatio.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_lib_reads_Infil.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_Ig_CS.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_lib_reads_Infil.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_TCR_lib_reads_Infil.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_TCR.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_TCR_clonality.Rdata&quot;,sep = &quot;&quot;)) #call the ploting function source(&quot;TRUST4/trust4_plot.R&quot;) meta &lt;- read.csv(&quot;metasheet.csv&quot;) p &lt;- Trust4_plot(phenotype = &quot;Responder&quot;, metasheet = meta) p "],["Infiltration.html", "Chapter 6 Immune Infiltration 6.1 Cibersort 6.2 TIMER 6.3 quanTIseq 6.4 xCell 6.5 EPIC 6.6 MCP-counter 6.7 Starting with TPM matrix", " Chapter 6 Immune Infiltration Cell infiltration estimation in the tumor microenvironment The tumor microenviroment (TME) is a complicated system consisting of immune cells, stromal cells, and extracellular factors. Estimating cell components is essential for classifying the distinct tumor immune microenvironment (TIME) phenotype. Furthermore, dissecting the TIME by evaluating cell components plays a significant role in untangling the mechanisms of tumor progression and immune evasion. Traditionally, there have been two major approaches for estimating cell infiltration in the TME – 1) deconvolution-based and 2) marker-based approaches. Deconvolution-based methods, such as TIMER, quanTIseq, EPIC, and CIBERSORT, consider a given gene expression profile as a linear combination of pre-defined immune gene signatures present at different ratios. A linear regression model is often applied to estimate the coefficients of genes, which are later used to infer immune cell abundances or fractions. Marker-based approaches, such as xCell and MCP-counter, quantify the signature enrichment score of a list of cell-specific marker genes from gene expression profiles. ImmuneDeconv is an R package that implements these six algorithms. All six algorithms estimate cell infiltration of immune cells, while three of the algorithms also estimate stromal cells. EPIC and quanTIseq also assess uncharacterized cells defined as cancer cells. Of note, CIBERSORT absolute mode, EPIC, and quanTIseq support inter-comparison between sample groups and intra-comparison between cell types. TIMER, xCell, and MCP-counter only support inter-comparison between sample groups within the same cell type. Immune cell deconvolution is still an open question in the field, and different algorithms could give slightly different results. A user may wish to evaluate the consistency of predictions stemming from different algorithms, the agreement of results with estimations from other modalities, and/or the derivation of the marker genes used for the tool. Newer algorithms are being developed which can utilize single-cell RNA-seq data as reference and which attempt to impute cell type-specific gene expression. These tools may improve predictions, especially if a well-annotated and compatible reference is available. 6.1 Cibersort Note: RIMA uses Cibersort in the immune_infiltration modules. Use of Cibersort requires registration for use of their gene signature matrix. In order to run the immune_infiltration module of RIMA, you must register and download the LM22.txt matrix from the CIBERSORT website . Once you obtain this file, add it to the ~/RIMA/RIMA_pipeline/static/cibersort folder. CIBERSORT is a deconvolution-based method that uses the v-support vector regression method (v-SVR) to estimate each immune cell type’s relative proportion from a gene expression profile (GEP). It requires an input of reference gene expression signatures. CIBERSORT provides a gene signature matrix (LM22.txt) which contains 547 genes and distinguishes 7 T-cell types, naïve and memory B cells, plasma cells, and NK cells. The CIBERSORT absolute mode scales cellular fractions to a score that reflects each cell type’s absolute proportion, allowing comparison across both samples and cell types. The CIBERSORT source code and LM22 signature matrix are only freely available to academic users – register for access on the CIBERSORT website . To run CIBERSORT using ImmuneDeconv: #demo suppressMessages(library(immunedeconv)) #read gene expression matrix input &lt;- &quot;tpm_convertID.txt&quot; #load CIBERSORT source code and signature matrix source(&quot;CIBERSORT.R&quot;) sig_matrix &lt;- &quot;LM22.txt&quot; #Run CIBERSORT abs #The number of permutation cibersort_perm = 100 #Quantile normalization of input mixture, default = FALSE for RNA-Seq data cibersort_qn = FALSE #whether to apply absolute mode in cibersort cibersort_abs = TRUE #sig.score = for each mixture sample, define S as the median expression,level of all genes in the signature matrix divided by the median expression level of all genes in the mixture. Multiple cell subset fractions by S. cibersort_abs_method = &quot;sig.score&quot; res_ciber &lt;- CIBERSORT(sig_matrix, input, perm = cibersort_perm, QN = cibersort_qn, absolute = cibersort_abs, abs_method = cibersort_abs_method) head(res_ciber,3) ## B cells naive B cells memory Plasma cells T cells CD8 ## SRR8281218 0.002023271 0.003060637 0.000000000 0.12297118 ## SRR8281219 0.010693087 0.000000000 0.001201108 0.38499197 ## SRR8281226 0.000000000 0.008281786 0.000000000 0.01442307 ## T cells CD4 naive T cells CD4 memory resting ## SRR8281218 0 0.14975225 ## SRR8281219 0 0.22216858 ## SRR8281226 0 0.08219228 ## T cells CD4 memory activated T cells follicular helper ## SRR8281218 0 0.08924869 ## SRR8281219 0 0.16924345 ## SRR8281226 0 0.06671124 ## T cells regulatory (Tregs) T cells gamma delta NK cells resting ## SRR8281218 0.09617560 0 0.06763887 ## SRR8281219 0.00000000 0 0.00000000 ## SRR8281226 0.04296535 0 0.07211706 ## NK cells activated Monocytes Macrophages M0 Macrophages M1 ## SRR8281218 0.0000000 0.06195550 0.0000000 0.01550602 ## SRR8281219 0.1076938 0.03659288 0.1552708 0.03207925 ## SRR8281226 0.0357515 0.41486727 0.0000000 0.00000000 ## Macrophages M2 Dendritic cells resting Dendritic cells activated ## SRR8281218 0.7049077 0 0.000000000 ## SRR8281219 1.1589577 0 0.000000000 ## SRR8281226 0.6474766 0 0.004669831 ## Mast cells resting Mast cells activated Eosinophils Neutrophils ## SRR8281218 0.11994310 0 0.003766691 0.00000000 ## SRR8281219 0.24218289 0 0.000000000 0.07942792 ## SRR8281226 0.01289667 0 0.002926060 0.12361329 ## P-value Correlation RMSE Absolute score (sig.score) ## SRR8281218 0.07 0.15699314 1.027475 1.436950 ## SRR8281219 0.24 0.05195861 1.072383 2.600503 ## SRR8281226 0.08 0.13503937 1.054532 1.528892 6.2 TIMER TIMER (Tumor IMmune Estimation Resource) uses linear least square regression to estimate six tumor-infiltrating immune cell types (B, CD4T, CD8T, neutrophils, macrophages, and dendritic cells). Since the tumor purity is very different across different cancer cell types, TIMER selects specific genes as immune signatures based on the correlation between gene expression and tumor purity. (see Bo Li, et al. for more information. Tutorial of TIMER’s web interface: Tutorial of TIMER2: Note that the TIMER score can only be compared within samples, and the current version of TIMER supports 23 different TCGA cancer types. #load gene expression matrix df &lt;- read.table(input, sep = &quot;,&quot;, row.names = 1, header = TRUE, check.names = FALSE) #The TCGA cancer acronyms of demo data cancertype &lt;- &quot;GBM&quot; #Available cancer type immunedeconv::timer_available_cancers res_timer = as.data.frame(deconvolute(df, &quot;timer&quot;,indications=rep(tolower(cancertype),ncol(df)))) 6.3 quanTIseq quanTIseq uses constrained least square regression to estimate absolute proportions of the infiltration levels of 10 immune cell types from RNA seq data. Therefore, the score of quanTIseq allows inter- or intra-sample comparison. quanTIseq provides an entire pipeline that can either process the pre-computed gene expression matrix (TPM matrix) or directly analyze bulk RNA-Seq data. RIMA uses the TPM matrix generated in the proprocessing modules for all immune infiltration algorithms. #Run quanTIseq res_quant = as.data.frame(deconvolute(df, &quot;quantiseq&quot;)) 6.4 xCell xCell performs single-sample gene set enrichment analysis (ssGSEA) on expression data to evaluate the enrichment of immune marker genes. These marker genes were validated using cytometry immunophenotyping and in-silico simulations. Note that results of xCell depend on the number of samples. The power of estimation might be lower if your dataset has limited non-heterogeneous samples. #Run xCell res_xcell = as.data.frame(deconvolute(df, &quot;xcell&quot;)) 6.5 EPIC EPIC uses constrained least square regression to estimate six immune cell types, fibroblasts, and endothelial cells. EPIC collects a unique gene expression reference from circulating and tumor-infiltrating cells. Further, it extended its algorithm to evaluate the uncharacterized cancer cells. The score that comes from the EPIC algorithm is an absolute value that can be compared within or across samples. #Run EPIC res_epic = as.data.frame(deconvolute(df, &quot;epic&quot;)) 6.6 MCP-counter MCP-counter uses its transcriptomic markers (TM) curated from 81 public datasets to estimate fibroblasts, endothelial cells, and eight immune cell types. #Run EPIC res_mcp = as.data.frame(deconvolute(df, &quot;mcp_counter&quot;)) 6.7 Starting with TPM matrix immune_infiltration.R contains R scripts for immune infiltration comparison analysis using a TPM matrix as input. Below is an example of running the scripts to obtain CIBERSORT absolute results: Rscript src/immune_infiltration/immune_infiltration.R -e exprsn -t cancer_type -p permutation -q FALSE -a TRUE -m abs_method -o out_dir Usage: -e expression file [Required] -o output directory [Required] -p permutation for cibersort -q whether enable quantile normalization for cibersort TRUE/FALSE -a whether enable absolute mode of cibersort TRUE/FALSE -m absolute method for cibersort_abs Default: &#39;sig.score&#39; -t cancer type for timer RIMA will generate immune infiltration results for all six algorithms which can be used to compare immune cell levels between phenotypes. After RIMA’s immune_infiltration module is run, text output files as well as boxplot, correlation and heatmap plots are stored in the analysis/immune_infiltration folder of the RIMA_pipeline. Example code is provided below for heatmap and boxplots like those generated by RIMA. CIBERSORT abs results are used as an example. If you wish to use this code to generate new figures, set “phenotype” in the hmap and boxfig calls to the appropriate column in metasheet.csv. 6.7.1 Correlation Plots RIMA generates correlation plots for 8 cell types. (B cells, CD4 T cells, CD8 Tcells, DCs, Macrophages, Treg cells, NK cells and Neutrophils) These image files display Spearman correlation values for all six algorithms, allowing you to compare cell estimations between algorithms. Figure 6.1: Volcano plot 6.7.2 Heatmaps for comparisons across cell types #extract the immune cell score from results of CIBERSORT res_ciber &lt;- res_ciber[,1:22] res_ciber ## B cells naive B cells memory Plasma cells T cells CD8 ## SRR8281218 0.002023271 0.003060637 0.000000000 0.12297118 ## SRR8281219 0.010693087 0.000000000 0.001201108 0.38499197 ## SRR8281226 0.000000000 0.008281786 0.000000000 0.01442307 ## SRR8281236 0.119197082 0.000000000 0.175028807 0.05841897 ## SRR8281230 0.000000000 0.001725996 0.000000000 0.02099308 ## SRR8281233 0.074569126 0.000000000 0.022548328 0.09612605 ## SRR8281244 0.000000000 0.133329588 0.041170411 0.58644201 ## SRR8281245 0.057960600 0.000000000 0.001729094 0.71691961 ## SRR8281243 0.021015715 0.000000000 0.000000000 0.05560813 ## SRR8281251 0.000000000 0.014652173 0.000000000 0.12265135 ## SRR8281238 0.010961877 0.000000000 0.000000000 0.07328546 ## SRR8281250 0.000000000 0.007211828 0.000000000 0.11124637 ## T cells CD4 naive T cells CD4 memory resting ## SRR8281218 0 0.1497522454 ## SRR8281219 0 0.2221685808 ## SRR8281226 0 0.0821922827 ## SRR8281236 0 0.0616983261 ## SRR8281230 0 0.2636255094 ## SRR8281233 0 0.0540161771 ## SRR8281244 0 0.0000000000 ## SRR8281245 0 0.1346463483 ## SRR8281243 0 0.2983063326 ## SRR8281251 0 0.0008469304 ## SRR8281238 0 0.1462044340 ## SRR8281250 0 0.0912421429 ## T cells CD4 memory activated T cells follicular helper ## SRR8281218 0 0.08924869 ## SRR8281219 0 0.16924345 ## SRR8281226 0 0.06671124 ## SRR8281236 0 0.02097714 ## SRR8281230 0 0.04434860 ## SRR8281233 0 0.01702242 ## SRR8281244 0 0.20198021 ## SRR8281245 0 0.08491094 ## SRR8281243 0 0.02547211 ## SRR8281251 0 0.13107578 ## SRR8281238 0 0.06549731 ## SRR8281250 0 0.08310786 ## T cells regulatory (Tregs) T cells gamma delta NK cells resting ## SRR8281218 0.096175601 0 0.06763887 ## SRR8281219 0.000000000 0 0.00000000 ## SRR8281226 0.042965351 0 0.07211706 ## SRR8281236 0.016105425 0 0.01389437 ## SRR8281230 0.003663422 0 0.06303278 ## SRR8281233 0.000000000 0 0.00000000 ## SRR8281244 0.000000000 0 0.00000000 ## SRR8281245 0.064756411 0 0.00000000 ## SRR8281243 0.024209477 0 0.02796011 ## SRR8281251 0.000000000 0 0.03345416 ## SRR8281238 0.000000000 0 0.00000000 ## SRR8281250 0.021319048 0 0.11199972 ## NK cells activated Monocytes Macrophages M0 Macrophages M1 ## SRR8281218 0.00000000 0.0619555028 0.0000000 0.0155060204 ## SRR8281219 0.10769382 0.0365928767 0.1552708 0.0320792458 ## SRR8281226 0.03575150 0.4148672695 0.0000000 0.0000000000 ## SRR8281236 0.01814658 0.0009746492 0.4032181 0.0265143088 ## SRR8281230 0.09185887 0.0765481976 0.0000000 0.0007397341 ## SRR8281233 0.12935356 0.3642042042 0.0000000 0.0146104309 ## SRR8281244 0.20599738 0.0000000000 0.0000000 0.0111442172 ## SRR8281245 0.03120120 0.2150193255 0.0000000 0.2086448744 ## SRR8281243 0.04129983 0.3731328017 0.0000000 0.0712853735 ## SRR8281251 0.01556184 0.1857497242 0.0000000 0.0649557029 ## SRR8281238 0.13490224 0.1832561460 0.0000000 0.0058262672 ## SRR8281250 0.05657334 0.2021661178 0.0000000 0.0026188791 ## Macrophages M2 Dendritic cells resting Dendritic cells activated ## SRR8281218 0.7049077 0.0000000000 0.000000000 ## SRR8281219 1.1589577 0.0000000000 0.000000000 ## SRR8281226 0.6474766 0.0000000000 0.004669831 ## SRR8281236 1.0709844 0.0000000000 0.000000000 ## SRR8281230 0.2730022 0.0005978992 0.000000000 ## SRR8281233 2.1503686 0.0000000000 0.000000000 ## SRR8281244 1.4746127 0.0000000000 0.000000000 ## SRR8281245 1.4430364 0.0000000000 0.000000000 ## SRR8281243 1.0892152 0.0000000000 0.000000000 ## SRR8281251 0.7517625 0.0000000000 0.000000000 ## SRR8281238 0.4755445 0.0004518878 0.000000000 ## SRR8281250 0.4947339 0.0000000000 0.003493596 ## Mast cells resting Mast cells activated Eosinophils Neutrophils ## SRR8281218 0.11994310 0.00000000 0.003766691 0.000000000 ## SRR8281219 0.24218289 0.00000000 0.000000000 0.079427915 ## SRR8281226 0.01289667 0.00000000 0.002926060 0.123613285 ## SRR8281236 0.06937423 0.00000000 0.000000000 0.017959545 ## SRR8281230 0.24554128 0.00000000 0.000000000 0.055268474 ## SRR8281233 0.00000000 0.04839376 0.000000000 0.008407325 ## SRR8281244 0.00000000 0.21527869 0.000000000 0.028385274 ## SRR8281245 0.21885148 0.00000000 0.000000000 0.040372665 ## SRR8281243 0.13542538 0.00000000 0.000000000 0.006578541 ## SRR8281251 0.00000000 0.20693722 0.001084478 0.058856146 ## SRR8281238 0.00000000 0.32409274 0.013953275 0.047135836 ## SRR8281250 0.00000000 0.10459983 0.000000000 0.035923878 #load plotfunction source(&quot;plotfunction.R&quot;) #load metasheet for RIMA pipeline metasheet &lt;- read.csv(&quot;metasheet.csv&quot;) #methods: CIBERSORT, quanTIseq, EPIC, MCP, xCell, TIMER hmap(ta = res_ciber, meta = metasheet, methods = &quot;CIBERSORT&quot;, phenotype = &quot;Responder&quot;) 6.7.3 Box plots for comparison across samples boxfig(ta = res_ciber, meta = metasheet, methods = &quot;CIBERSORT&quot;, phenotype = &quot;Responder&quot;) "],["Response.html", "Chapter 7 Immune Response 7.1 Characterizing the TME and T cell functionality 7.2 TIDE 7.3 Microsatelite instability (MSI) 7.4 Response comparison analysis of biomarkers", " Chapter 7 Immune Response The immune_response module will run two tools – TIDE and MSISensor2. Background and specific details about both of these tools is included below. 7.1 Characterizing the TME and T cell functionality Cancer immunotherapy utilizing immune checkpoint blockade (ICB) has made excellent progress in treating advanced-stage patients. However, only a small fraction of patients achieve a response to immunotherapy due to the complexity and heterogeneity of the TME. An increasing number of biomarkers have widely been used to estimate the clinical effectiveness of immunotherapy, such as ICB-related gene signatures (PD1, PDL1, CTLA4), tumor-infiltrating lymphocytes, tumor mutation burden, neoantigens, microsatellite instability (MSI) and serum markers. Nevertheless, there is an urgent need to build a method integrating multiple dynamic factors to characterize the TME and predict immunotherapy response. Currently, two major approaches have been effectively utilized in immunotherapy response prediction. In one approach models are constructed using transcriptome expression profiles of immune checkpoint or T-cell activity. In the other approach, artificial intelligence-based algorithms are developed using imaging characteristics of lesions. For tumor RNA-seq data, TIDE (Tumor Immune Dysfunction and Exclusion) models tumor immune evasion by combining gene signatures estimating T cell dysfunction and exclusion to predict ICB response, which may provide critical insights to guide clinical treatment. This computational framework computes the TIDE score for tumors and separates them into responders and non-responders. In detail, TIDE provides a T cell dysfunction score, a T cell exclusion score, a cytotoxic T lymphocyte score, and scores of cell types restricting T cell infiltration in TME, including cancer-associated fibroblasts (CAF), myeloid-derived suppressor cells (MDSC), and M2 macrophages. These metrics help the biologists understand the TME status or T cell functions of interest. In this case, tumor RNA-seq profiling leverages the power of gene signature expression for quantifying the dynamic TME status, providing guidance for immunotherapy response prediction for clinicians. 7.2 TIDE TIDE is both a transcriptome biomarker database of ICB response and a set of algorithms to model tumor immune dysfunction and exclusion and predict immunotherapy response. The statistical model of TIDE was trained on clinical tumor profiles without ICB treatments since the immune evasion mechanisms in treatment naïve tumors are also likely to influence patient response to immunotherapies. The TIDE model has been applied to evaluate T cell dysfunction and exclusion signatures across over 33K samples in 188 tumor cohorts from well-curated databases, including TCGA, METABRIC, and PRECOG, as well as our in-house data collections. More information about how TIDE’s measures of immune cell dysfunction and exclusion were derived can be found below and at Peng Jiang, et al. A command line TIDE is available at https://github.com/liulab-dfci/TIDEpy. 7.2.1 Config.yaml sections relevant to TIDE For running TIDE within RIMA, the config.yaml file contains a few parameters that affect the results. The top half of a sample config.yaml file is included below for reference. If “cancer_type” is NSCLC or Melanoma, TIDE will use the response prediction parameters that were developed specifically for these cancer types. The parameter “pre_treated” is used to indicate whether samples are from participants who received immunotherapy prior to the current study. For cohort reports from TIDE, the phenotype used for comparison is the one identified in the config.yaml cohort parameter section. This section is described in more detail in Chapter 4.2.1. To exclude samples from the analysis, please see how to set up the Group column of the metasheet.csv file in Chapter 2. --- metasheet: metasheet.csv ref: ref.yaml assembly: hg38 cancer_type: GBM #TCGA cancer type abbreviations or, for TIDE only, NSCLC or Melanoma if applicable rseqc_ref: house_keeping #option: &#39;house_keeping&#39; or &#39;false&#39;. By default, a subset of housekeeping genes is used by rseqc to assess alignment quality. This reduces the amount of time needed to run rseqc. mate: [1,2] #paired-end fastq format #########Parameter used for cohort level analysis################ design: Group #condition on which to do comparsion (as set up in metasheet.csv) Treatment: R Control: NR batch: syn_batch #option: false or a column name from the metasheet.csv. If set to a column name in the metasheet.csv, the column name will be used for batch effect analysis (limma). It will also be used as a covariate for differential analysis (DeSeq2) to account for batch effect. pre_treated: false #option: true or false. If set to false, patients are treatment naive. If set to true, patients have received some form of therapy prior to the current study. 7.2.2 Cold and hot tumors TIDE estimates the cytotoxic T Lymphocyte (CTL) level in tumors from the average expression of CD8A, CD8B, GZM, GZMB and PRF1 from treatment naïve tumors. ‘Hot tumors’ have above-average CTL values among all samples, while ‘Cold tumors’ have CTL values below average. The TIDE score is a combination of the T cell dysfunction estimated from hot tumors and the T cell exclusion estimated from cold tumors. 7.2.3 T cell dysfunction TIDE’s T cell dysfunction score was derived by systematically identifying genes that interact with CTL infiltration levels to influence patient survival. The genes utilized for the T-cell dysfunction model were identified in the following manner. For hot tumors with high CTL values, the T cell dysfunction is modeled from Cox-PH regression: \\[ Hazard = a*CTL+b*P+d*CTL*P \\] Where the variable CTL represents the CTL level, P represents the expression level of a candidate gene and the coefficient d reflects the effect of the interaction between the CTL and candidate gene P on death hazard. The T cell dysfunction score of each gene is calculated as: \\[ Dysfunction = \\frac{d}{StdErr(d)} \\] Dysfunction scores of each gene were then compared to identify genes with statistically significant influences on CTL and death hazard. 7.2.4 T cell exclusion TIDE calculates a T cell exclusion score to estimate immune escape. The T cell exclusion score is derived from the expression profiles of three cell types which have been reported to restrict T cell infiltration in tumors – cancer-associated fibroblasts (CAFs), myeloid-derived suppressor cells (MDSCs) and tumor-associated macrophages (TAMs). 7.2.5 Normalization The input for TIDE is a normalized TPM matrix, the steps for normalization are: Log transform the data: log2(TPM+1). For each gene, subtract the average of the log transformed expression levels across all of your samples. 7.2.6 Running TIDE TIDE supports cancer type specific analysis of melanoma and non-small cell lung cancer (NSCLC). In our example, the data is from glioblastoma multiforme (GBM), so RIMA will set -c as other cancer type and force TIDE to normalize the TPM matrix. TIDE is run from a command line interface with a command like the following: tidepy -o TIDE_score.txt -c Other --force_normalization tpm_convertID.txt Example outputs of TIDE: tide_res &lt;- read.table(&quot;TIDE_score.txt&quot;,header=TRUE,sep=&#39;\\t&#39;) print(tide_res) ## X No.benefits Responder TIDE IFNG MSI.Score ## 1 SRR8281219 False False 1.6807050 0.05776435 0.9171423549 ## 2 SRR8281236 False False 1.4737267 -0.44182240 0.0891168795 ## 3 SRR8281251 False False 0.3144625 0.72752075 0.9280729250 ## 4 SRR8281233 False True -0.5123185 0.34811417 0.5993703233 ## 5 SRR8281244 False True -0.9853986 0.21431441 0.9799730558 ## 6 SRR8281238 False True -1.9248032 -0.90589129 0.0009766364 ## 7 SRR8281230 True False 1.1296130 -1.26863334 0.2538437260 ## 8 SRR8281245 False False 0.4289897 3.88767936 0.0017826161 ## 9 SRR8281250 False False 0.3857392 -1.24755461 0.9386137813 ## 10 SRR8281226 False False 0.1014286 -1.21158487 0.9948723196 ## 11 SRR8281218 False True -0.6018754 -1.00643540 0.9824508826 ## 12 SRR8281243 False True -0.6690983 0.84652886 0.0098136280 ## CD274 CD8 CTL.flag Dysfunction Exclusion MDSC ## 1 1.614004697 1.0782170 False -0.80734665 1.6807050 0.12475420 ## 2 -0.571334617 -1.9530623 False -0.35635988 1.4737267 0.11729077 ## 3 -0.000579565 -1.3454258 False -0.37740657 0.3144625 0.10977895 ## 4 -0.411058820 -0.6337873 False 0.53196445 -0.5123185 -0.14295622 ## 5 -0.606725356 3.4653282 False 0.08913789 -0.9853986 -0.10578784 ## 6 -0.024306339 -0.6112697 False 0.92111671 -1.9248032 -0.11623220 ## 7 0.770622520 -1.5651339 False -0.37601870 1.1296130 0.09720250 ## 8 1.057713700 5.4054676 True 0.42898972 -0.5965523 -0.04806820 ## 9 -1.316139124 -1.0777690 False -0.23234131 0.3857392 0.05575237 ## 10 -0.867420745 -1.6865379 False -0.80196436 0.1014286 -0.01248780 ## 11 -1.080325919 -0.2808955 False 0.39883468 -0.6018754 -0.05455741 ## 12 1.435549568 -0.7951312 False 0.70257668 -0.6690983 -0.05677437 ## CAF TAM.M2 ## 1 0.15396889 -0.026495315 ## 2 0.07706755 0.026260679 ## 3 -0.08909806 0.018044264 ## 4 0.05095308 0.014947245 ## 5 -0.04049768 -0.009330085 ## 6 -0.14906967 -0.015234391 ## 7 0.06391605 0.003882855 ## 8 0.03353989 -0.073846662 ## 9 -0.03536659 0.035777532 ## 10 0.02156957 0.002648255 ## 11 -0.08670749 0.057716177 ## 12 -0.01752071 -0.019989212 7.3 Microsatelite instability (MSI) Microsatelite instability (MSI) is the condition of genetic hypermutability (predisposition to mutation) that results from impaired DNA mismatch repair (MMR). Previous studies have shown that the MSI is highly associated with tumor mutation burden and closly related to immunotherapy response. Many tools such as MANTIS, MSIsensor, mSINGS and MSIsensor-pro are available to calculate MSI scores from RNA-seq data. In our RIMA pipeline, we applied MSIsensor2 to estimate MSI scores, which allows for tumor-only BAM input. #Run MSIsensor2 msisensor2 msi -M models_hg38 -t tumor.bam -o tumor ## Output of MSIsensor2 Total_Number_of_Sites Number_of_Somatic_Sites % 156 26 16.67 Example of combined MSI outputs: msi_res &lt;- read.table(&quot;msi_score.txt&quot;,header=FALSE,sep=&#39;\\t&#39;) print(msi_res) ## V1 V2 ## 1 SRR8281218 20.34 ## 2 SRR8281219 13.39 ## 3 SRR8281226 28.00 ## 4 SRR8281238 22.11 ## 5 SRR8281236 17.69 ## 6 SRR8281230 16.10 ## 7 SRR8281233 17.97 ## 8 SRR8281244 25.71 ## 9 SRR8281245 30.43 ## 10 SRR8281243 24.11 ## 11 SRR8281251 23.44 ## 12 SRR8281250 24.59 7.4 Response comparison analysis of biomarkers RIMA combines the output from TIDE and MSIsensor2 in a report that compares cohorts. The phenotype used for comparison is the one identified in the config.yaml cohort parameter section. This section is described more in Chapter 4.2.1. The report figure can be found in the TIDE subfolder within RIMA_pipeline/analysis. #read the metasheet metafile &lt;- &quot;metasheet.csv&quot; tide_res &lt;- &quot;TIDE_score.txt&quot; msi_res &lt;- &quot;msi_score.txt&quot; #load ploting function source(&quot;Tideploting.R&quot;) cmpr_biomk(msi_path = msi_res, tide_path = tide_res, meta_path = metafile, phenotype = &quot;Responder&quot;) Figure 7.1: Comparision of biomarkers between R and NR "],["HLA.html", "Chapter 8 HLA Typing &amp; Neoantigens 8.1 Identify HLA type 8.2 HLA Oncoplot 8.3 Neoantigen Identification", " Chapter 8 HLA Typing &amp; Neoantigens Tumor mutations can result in altered proteins, which might act as neoantigens and potentially elicit an immune response. Algorithms, such as those available in pVAC-Tools can be used to predict neoantigen peptides. In order to elicit an adaptive immune response, a peptide must be presented on a cell’s surface bound to major histocompatibility (MHC) protein complexes. The human leukocyte antigen (HLA) complex on chromosome 6 encodes most of the proteins that make up the human MHCs. The HLA complex is highly polymorphic and encodes MHCs that have different propensities to present different peptides. Two major classes of human MHC, class I and class II, (encoded by HLA-I and HLA-II alleles, respectively) are involved in antigen presentation. MHC class I protein complexes are expressed on all normal cells and present internally degraded proteins, while MHC class II protein complexes are normally expressed on professional antigen-presenting cells and present processed external antigens. The antigen binding portions of the MHC class I protein complexes are encoded by the HLA-I genes HLA-A, HLA-B and HLA-C. The antigen binding portions of the MHC class II proteins are encoded by alpha (A) and beta (B) genes in the DP, DQ and DR regions of the HLA complexes. These HLA-II genes include HLA-DQA1, HLA-DQB1 and HLA-DRB1. Neoantigen prediction algorithms usually integrate peptide/MHC binding predictions using tools such as NetMHCpan, MHCflurry, and SMMalign. Knowing the HLA type is necessary to identify potential neoantigens for targeted immunotherapy. Current alignment-based HLA typing methods require DNA or RNA sequencing inputs and predict HLA-I class only or both of HLA-I and HLA-II classes. For example, arcasHLA, HLAProfiler, and seq2HLA have been developed to perform high-solution HLA typing from RNA-seq data. OptiType and PHLAT are other HLA identification tools for RNA, whole-exome, and whole-genome sequencing data. HLA reference sequences can be obtained from the ImMunoGeneTics (IMGT) database. 8.1 Identify HLA type HLA Typing is a part of the neoantigen prediction module of RIMA. RIMA uses arcasHLA to predict HLA types for both MHC Class I &amp; Class II from the bulk RNA-seq data. The sorted alignment BAM files generated by STAR are used for input to arcasHLA. Here we use one sample from the Zhao trial as an example. We first extract the HLA reads from the alignment file: ### Extract fastq reads arcasHLA extract analysis/STAR/SRR8281218/SRR8281218.sorted.bam -t 16 -v --sample SRR8281218 -o analysis/neoantigen/SRR8281218 ### Output from extraction analysis/neoantigen/SRR8281218/SRR8281218.extracted.1.fq.gz analysis/neoantigen/SRR8281218/SRR8281218.extracted.2.fq.gz Then we identify the HLA alleles using the extracted reads: arcasHLA genotype analysis/neoantigen/SRR8281218/SRR8281218.extracted.1.fq.gz analysis/neoantigen/SRR8281218/SRR8281218.extracted.2.fq.gz -g A,B,C,DQA1,DQB1,DRB1 -t 16 -v -o analysis/neoantigen/SRR8281218 ###Output from extraction analysis/neoantigen/SRR8281218/SRR8281218.genotype.json cat analysis/neoantigen/SRR8281218/SRR8281218.genotype.json ### {&quot;A&quot;: [&quot;A*26:01:01&quot;, &quot;A*03:01:01&quot;], &quot;B&quot;: [&quot;B*35:01:01&quot;, &quot;B*07:02:01&quot;], &quot;C&quot;: [&quot;C*07:02:01&quot;, &quot;C*04:01:01&quot;], &quot;DQA1&quot;: [&quot;DQA1*02:01:01&quot;, &quot;DQA1*03:01:01&quot;], &quot;DQB1&quot;: [&quot;DQB1*03:02:01&quot;], &quot;DRB1&quot;: [&quot;DRB1*04:02:01&quot;, &quot;DRB1*07:01:01&quot;]} ### Merge individual HLAs RIMA also merges the individual HLA results from arcasHLA into a summary file named ‘genotypes.tsv’: subject A1 A2 B1 B2 C1 C2 DQA11 DQA12 DQB11 DQB12 DRB11 DRB12 SRR8281238 A*01:01:01 A*02:01:01 B*35:01:01 B*08:01:01 C*07:01:01 C*04:01:01 DQA1*05:01:01 DQA1*01:01:01 DQB1*02:01:01 DQB1*05:01:01 DRB1*01:01:01 DRB1*03:01:01 SRR8281233 A*01:01:01 A*02:01:01 B*57:01:01 B*44:02:01 C*05:01:01 C*06:02:01 DQA1*01:02:01 DQA1*03:01:01 DQB1*06:02:01 DQB1*03:02:01 DRB1*04:01:01 DRB1*15:01:01 SRR8281236 A*33:01:01 A*24:02:01 B*14:02:01 B*15:01:01 C*06:02:01 C*08:02:01 DQA1*01:02:02 DQA1*03:01:01 DQB1*03:02:01 DQB1*05:02:01 DRB1*04:03:01 DRB1*16:02:01 SRR8281243 A*01:01:01 A*24:02:01 B*35:02:01 B*41:01:01 C*04:01:01 C*17:01:01 DQA1*01:02:01 DQA1*01:05:01 DQB1*05:01:01 DQB1*06:09:01 DRB1*10:01:01 DRB1*13:02:01 SRR8281251 A*24:02:01 A*01:01:01 B*35:02:01 B*41:01:01 C*04:01:01 C*17:01:01 DQA1*01:02:01 DQA1*01:05:01 DQB1*05:01:01 DQB1*06:09:01 DRB1*10:01:01 DRB1*13:02:01 SRR8281230 A*01:01:01 A*02:01:01 B*57:01:01 B*44:02:01 C*05:01:01 C*06:02:01 DQA1*03:01:01 DQA1*01:02:01 DQB1*03:02:01 DQB1*06:02:01 DRB1*04:01:01 DRB1*15:01:01 SRR8281250 A*01:01:01 A*02:01:01 B*35:01:01 B*08:01:01 C*07:01:01 C*04:01:01 DQA1*05:01:01 DQA1*01:01:01 DQB1*02:01:01 DQB1*05:01:01 DRB1*01:01:01 DRB1*03:01:01 SRR8281244 A*25:01:01 A*02:01:01 B*18:01:01 B*08:01:01 C*07:02:01 C*12:03:01 DQA1*01:02:01 DQA1*01:02:01 DQB1*06:02:01 DQB1*06:02:01 DRB1*15:01:01 DRB1*15:01:01 SRR8281218 A*26:01:01 A*03:01:01 B*35:01:01 B*07:02:01 C*07:02:01 C*04:01:01 DQA1*02:01:01 DQA1*03:01:01 DQB1*03:02:01 DQB1*03:02:01 DRB1*04:02:01 DRB1*07:01:01 8.2 HLA Oncoplot To better visualize and compare the HLA distribution in different samples, we use arcasHLA to convert HLA results to P-group format. The P-group format shows the alleles which share the same amino acid sequence in the antigen-binding region. (eg. A*01:01P, ‘P’ indicates p-group nomenclature) ### #HLA summary file: genotypes.tsv arcasHLA convert -r p-group genotypes.tsv -o genotypes.p-group.tsv ### subject A1 A2 B1 B2 C1 C2 DQA11 DQA12 DQB11 DQB12 DRB11 DRB12 SRR8281233 A*01:01P A*02:01P B*57:01P B*44:02P C*05:01P C*06:02P DQA1*01:02P DQA1*03:01P DQB1*06:02P DQB1*03:02P DRB1*04:01P DRB1*15:01P SRR8281236 A*33:01P A*24:02P B*14:02P B*15:01P C*06:02P C*08:02P DQA1*01:02P DQA1*03:01P DQB1*03:02P DQB1*05:02P DRB1*04:03P DRB1*16:02P SRR8281243 A*01:01P A*24:02P B*35:02P B*41:01P C*04:01P C*17:01P DQA1*01:02P DQA1*01:01P DQB1*05:01P DQB1*06:09P DRB1*10:01P DRB1*13:02P SRR8281244 A*25:01P A*02:01P B*18:01P B*08:01P C*07:02P C*12:03P DQA1*01:02P DQA1*01:02P DQB1*06:02P DQB1*06:02P DRB1*15:01P DRB1*15:01P SRR8281250 A*01:01P A*02:01P B*35:01P B*08:01P C*07:01P C*04:01P DQA1*05:01P DQA1*01:01P DQB1*02:01P DQB1*05:01P DRB1*01:01P DRB1*03:01P SRR8281219 A*03:01P A*26:01P B*35:01P B*07:02P C*07:02P C*04:01P DQA1*02:01P DQA1*03:01P DQB1*03:02P DQB1*03:03P DRB1*04:02P DRB1*07:01P SRR8281245 A*25:01P A*02:01P B*18:01P B*08:01P C*07:02P C*12:03P DQA1*01:02P DQA1*01:02P DQB1*06:02P DQB1*06:02P DRB1*15:01P DRB1*15:01P SRR8281230 A*01:01P A*02:01P B*57:01P B*44:02P C*05:01P C*06:02P DQA1*03:01P DQA1*01:02P DQB1*06:02P DQB1*03:02P DRB1*04:01P DRB1*15:01P SRR8281251 A*24:02P A*01:01P B*35:02P B*41:01P C*04:01P C*17:01P DQA1*01:02P DQA1*01:01P DQB1*05:01P DQB1*06:09P DRB1*10:01P DRB1*13:02P SRR8281218 A*26:01P A*03:01P B*35:01P B*07:02P C*07:02P C*04:01P DQA1*02:01P DQA1*03:01P DQB1*03:02P DQB1*03:02P DRB1*04:02P DRB1*07:01P SRR8281238 A*01:01P A*02:01P B*35:01P B*08:01P C*07:01P C*04:01P DQA1*05:01P DQA1*01:01P DQB1*02:01P DQB1*05:01P DRB1*01:01P DRB1*03:01P SRR8281226 A*33:01P A*24:02P B*14:02P B*15:01P C*06:02P C*08:02P DQA1*03:01P DQA1*01:02P DQB1*05:02P DQB1*03:02P DRB1*04:03P DRB1*16:02P RIMA generates an HLA oncoplot which shows the most frequent HLA alleles across patient cohorts and the expression level of HLA genes (HLA-A, HLA-B, HLA-C, HLA-DQA1, HLA-DQB1, and HLA-DRB1). The percentages on the left of the heatmap represent the frequency of the allele among samples. The colors in the heatmap indicate which allele (e.g. A = HLA-A) and whether the allele was found in the first (A1), the second (A2) or both copies of the patient’s gene. The colored bars to the right indicate the absolute number of alleles found. The x axis represents patient samples. The samples are sorted by group and then by the expression of HLA genes within the group. The HLA expression shown on the top represents the mean TPM of HLA genes in each sample. #load HLA p-group summary file hla &lt;- read.table(&quot;genotypes.p-group.tsv&quot;, header = TRUE, sep = &quot;\\t&quot;) #load metasheet meta &lt;- read.table(&quot;metasheet.csv&quot;, sep = &quot;,&quot;, header = TRUE, row.names = 1) #load gene expression matrix exprn &lt;- read.table(&quot;tpm_convertID.txt&quot;, header = TRUE, row.names = 1, sep = &quot;,&quot;, check.names = FALSE) source(&quot;hla_oncoplot.R&quot;) #group indicates which columns are used for hla comparison index &lt;- c(&quot;Responder&quot;, &quot;Gender&quot;) p &lt;- hla_oncoplot(hla, exprn, meta, groups = index) ## All mutation types: C2, DQA12, DQB11, DQB12, B1, C1, A2, A1, B2, DQA11, ## DRB11, DRB12. ## `alter_fun` is assumed vectorizable. If it does not generate correct ## plot, please set `alter_fun_is_vectorized = FALSE` in `oncoPrint()`. print(p) 8.3 Neoantigen Identification To identify neoantigens, we will need the somatic mutation and HLA allele information introduced in previous sub-chapters. The standard approach for somatic mutation detection is the analysis of whole-exome (WES) or whole-genome sequencing data from tumor-normal matched pairs. Computational algorithms are used to call mutations from the resulting data. For example, MuTect is based on a Bayesian classifier, MuSE is based on a Bayesian Markov model, SomaticSniper is based on a Bayesian comparison of genotype likelihoods, and Varscan2 is based on a heuristic algorithm classifying somatic status. Among these approaches, Varscan2 can be applied to RNA-seq data with good coverage, although the mutation calls are still expected to be noisier than those from DNA sequencing. After somatic mutation detection, VEP can be used to annotate mutations on genes, transcripts, and regulatory regions. Sinee it’s not common to have deep-sequenced tumor-normal paired samples, current RIMA is not supporting the function of calling somatic mutation from RNA-seq data. In this chapter, we are showing the example of identifying expressed neoantigens integrating both RNA-seq and WES data. Here we use one matched tumor-normal sample for both RNA and WES of the same patient from the Zhao trial as an example. We use RIMA preprocessing module to get the Salmon gene quantification SRR7588416.format.quant.sf. We use the WES pipeline to process the tumor fastq reads (SRR7588416) and matched normal fastqs (SRR7588421): Somatic Mutation is being called using Sentieon Somatic Caller to output a VCF file. Next, we annotate the VCF file with Ensembl Variant Effect Predictor (VEP) . SRR7588416_tnscope.neoantigen.vep.vcf is the example of VEP annotated VCF output. The ‘vcf-expression-annotator’ tool from pVAC-Tools can be used to add the expression information from the outputs obtained from Salmon. This will add “TX” (i.e Transcript Expression) tag to the ‘FORMAT’ column of the VCF output SRR7588416_tnscope.neoantigen.vep.rna.vcf. Optitype and xHLA are used to get the MHC Class I&amp;II allels results. SRR7588416_result_optitype.tsv and SRR7588416_result_xHLA.json stores HLA alleles results respectively. After generating the somatic hypermutation with expression information, and MHC class I&amp;II alleles, we used ‘pvacseq run’ command to estimate the peptide binding affinity to predicted HLAs. SRR7588416.all_epitopes.tsv is th example results of MCH Class I&amp;II peptides with length ranges from 8 to 18 predicted by NetMHCpan and NetMHCIIpan. SRR7588416.all_epitopes.aggregated.tsv is the aggreagated results of the best-scoring (lowest binding affinity) epitope. Detailed information of columns in each output file can be found here. "],["fusion.html", "Chapter 9 Fusion 9.1 Fusion calling 9.2 Remove fusion homology 9.3 Comparison within phenotype", " Chapter 9 Fusion Fusion genes have been considered a type of cancer driver which exert their oncogenic impact on tumor progression through chromosome rearrangement. There are two major fusion detection strategies: 1) read mapping-first which identifies discordant mapping reads as rearrangements; or 2) transcript assembly-first which identifies chimeric transcripts consistent with known rearrangements. Large-scale tumor sample screening requires fast and accurate fusion detection tools. STAR-Fusion is a common tool to predict fusions from the transcriptome which leverages discordant and chimeric read alignments from STAR. The output from STAR-fusion may include homologous fusion genes. After identifying fusion genes using STAR-fusion, RIMA will filter out homologous fusion genes using pyPRADA. pyPRADA calculates a homology score according to the sequence similarity of the two fusion transcripts. Fusion genes with a BitScore &lt; 100 are filtered from the final output of STAR-fusion. 9.1 Fusion calling In the mutation module of RIMA, RIMA runs STAR Fusion to generate a list of candidate fusion transcripts from the the chimeric output file ‘{sample_id}.Chimeric.out.junction’ generated by STAR as mentioned in Chapter 3.1. The output from STAR-Fusion is a tab-delimited file named ‘star-fusion.fusion_predictions.tsv’. This file provides information on fused gene names, junction read count and breakpoint information which are used in the next section. STAR-Fusion --chimeric_junction analysis/star/sample/sampleChimeric.out.junction --genome_lib_dir ./ref_files/fusion_gdc_index/GRCh38_v22_CTAT_lib_GDC_Mar162019/ctat_genome_lib_build_dir --output_dir analysis/fusion/sample 9.2 Remove fusion homology RIMA uses pyPRADA to calculate the homology score between pair of fusion genes in the fusion calling result. RIMA first removes the duplicated fusion genes from the fusion calling result and then runs homology between the genes. This part requires a configuration file containing information about the gene annotation and the output feature file. These are pre-compiled and can be found in RIMA’s static directory. prada-homology -i analysis/fusion/sample_pyprada_fusion_table.txt -o analysis/fusion/sample_pyprada_output.txt -tmpdir analysis/fusion/tmp/ -conf static/fusion/prada_config.txt The output of the homology analysis is a text file which contains information on Identity, Alignment length, Evalue and BitScore for each pair of fusion genes. Fusion gene pairs with BitScore &lt; 100 will be filtered out. Below is an example of the homology scores from pyPRADA: Figure 9.1: pyPRADA Homology Scores 9.3 Comparison within phenotype RIMA has a customized script that annotates genes as cancer drivers, oncogenes or tumor suppressors. RIMA also plots gene fusion expression between treatment (responders) and control (non-responders). Rscript src/mutation/fusion_plot.R --pradafusion analysis/fusion/Group_pyprada_output.txt --meta metasheet.csv --expression analysis/batchremoval/tpm.genesymbol.batchremoved.csv --annot static/fusion/cancerGeneList.tsv --outdir analysis/fusion/ --phenotype Group --input analysis/fusion/merged_Group_predictions.abridged_addSample.tsv Figure 9.2: Fuison violine plot Figure 9.3: Fusion box plot "],["microbiome.html", "Chapter 10 Microbiome 10.1 Centrifuge 10.2 Microbial classfication from RNA-seq data", " Chapter 10 Microbiome With the advantage of high-throughput sequencing, we are able to explore the genomes of the tumor-bearing host and the various microbes that reside in the host. It has been reported that the dynamics between microbiota and hosts may influence tumor growth and affect treatment approaches. Notably, gastrointestinal microbiota has been widely recognized for its role in cancer development and its association with cancer therapy response and toxicity. Previous studies have investigated the multiple ways in which gut microbiota influence anti-tumor immunity. For example, the modulation of microbial components helps to enhance T cell response and improve anti-PDL1 efficacy in melanoma patients. In addition, microbial metabolites can provide an energy source for neoplastic progression in colon cancer. Thus, it is essential to decipher microbiota components from the following perspectives: 1) the interactions between disease phenotypes and microbiota; 2) the relationship between treatment efficacy and microbiota enrichment; 3) the involvement of microbiota in condition-specific metabolism pathways; and 4) the application value of microbiota as a diagnostic biomarker. As a whole, the aim of microbiota classification analysis is to help elucidate novel mechanisms of disease development, potentially providing new insights into therapeutic target discovery. For decades, microbial phylogeny and taxonomy have relied on 16S rRNA sequencing and shot gun sequencing, which contains hypervariable regions as species-specific signatures for microbial identification. To perform computationally robust and effective microbiota classification, researchers have developed reference-genome-based methods from high-throughput DNA or RNA sequencing, such as PathSeq and Centrifuge. PathSeq aligns non-host reads to pre-defined microbial organisms using BWA-MEM alignment, while Centrifuge builds a compressed index merged with unique genome sequences in advance. Although both methods achieve microbiota classification and abundance estimation based on a users’ reference, Centrifuge outperforms PathSeq in measures of both memory usage and speed. 10.1 Centrifuge Centrifuge is a rapid and memory-efficient microbial classification engine that enables fast and sensitive labeling of reads and quantification of species. Centrifuge utilizes FM-index, a compact data structure widely used for short read alignment, to store all the sequence information in the database. For read classification, Centrifuge looks for stretches of long matches greedily between a read and the reference database and scores the taxonomy classification based on the match size. The species or genus with the highest score will be the taxonomy classification result for a read. Reads can be assigned to multiple species, so Centrifuge utilizes the Expectation-Maximization algorithm to quantify the abundance for the identified species. Due to the increasing size of the microbiome reference database, Centrifuge takes advantage of the high sequence similarity between species under the same genus and can compress the reference database. 10.2 Microbial classfication from RNA-seq data The reference index for Centrifuge (bacteria, archaea, viruses and human) can be downloaded from here . The microbiome module of RIMA uses raw fastq reads as input for Centrifuge and a classification report will be generated centrifuge -x ref_files/centrifuge_index/p_compressed+h+v -p 16 --host-taxids 9606 \\ -1 data/SRR8281218_1.fastq.gz -2 data/SRR8281218_2.fastq.gz \\ -s analysis/microbiome/SRR8281218/SRR8281218_classification.txt.gz \\ --report-file analysis/microbiome/SRR8281218/SRR8281218_report.txt We added a sample name column to each individual report and merged them together. Below is an example of a summary report with sample names added. sample name taxID taxRank genomeSize numReads numUniqueReads abundance SRR8281218 Azorhizobium caulinodans 7 species 5369772 6 6 4.85856e-05 SRR8281218 Stigmatella aurantiaca 41 species 10260756 1 1 0.0 SRR8281218 Chondromyces crocatus 52 species 11388132 3 2 0.0 SRR8281218 Sorangium cellulosum 56 species 13907952 3 1 0.0 SRR8281218 Caulobacter 75 genus 0 1 0 0.0 SRR8281218 Planctopirus limnophila 120 species 5460085 1 0 0.0 SRR8281218 Pirellula staleyi 125 species 6196199 2 1 0.0 SRR8281218 Isosphaera pallida 128 species 5529304 1 0 0.0 SRR8281218 Spirochaeta thermophila 154 species 2516433 3 3 0.0 From the results, RIMA selects the top 15 most enriched microbiota according to the Inverse Simpson Index and plots their relative abundance ratio at the cohort level. Figure 10.1: Microbiome Abundance plot "],["customize-your-own-reference.html", "Chapter 11 Customize your own reference 11.1 Reference fasta 11.2 Gene annotation file (gtf) 11.3 build STAR index 11.4 RSeQC reference files 11.5 build salmon index 11.6 STAR-Fusion genome resource lib 11.7 Centrifuge index 11.8 TRUST4 reference files", " Chapter 11 Customize your own reference RIMA provides a pre-built set of references using GDC hg38 and v22 GENCODE annotation. This set of references can be downloaded as described in chapter 2.2. We have also pre-built a set of reference files using v27 GENCODE annotation. This set of pre-built references can be downloaded from http://cistrome.org/~lyang/ref_v27.tar.gz using the same instructions provided in chapter 2. If you wish to build a different set of references, please follow the instructions which follow. 11.1 Reference fasta Download the human GDC hg38 fasta file from GDC website. 11.2 Gene annotation file (gtf) Dowload the human gtf annotation file from GENCODE website. 11.3 build STAR index Build the STAR index using the following code. Make sure to change the file names to indicate which gencode version you are using. conda activate rna ## STAR Version: STAR_2.6.1d STAR --runThreadN 16 --runMode genomeGenerate --genomeDir ./ref_files/v27_index --genomeFastaFiles GRCh38.d1.vd1.CIDC.fa --sjdbGTFfile gencode.v27.annotation.gtf ... 00:04:54 ..... started STAR run 00:04:54 ... starting to generate Genome files 00:05:57 ... starting to sort Suffix Array. This may take a long time... 00:06:11 ... sorting Suffix Array chunks and saving them to disk... 00:17:43 ... loading chunks from disk, packing SA... 00:19:31 ... finished generating suffix array 00:19:31 ... generating Suffix Array index 00:23:20 ... completed Suffix Array index 00:23:20 ..... processing annotations GTF 00:23:35 ..... inserting junctions into the genome indices 00:26:49 ... writing Genome to disk ... 00:27:06 ... writing Suffix Array to disk ... 00:28:53 ... writing SAindex to disk 00:29:05 ..... finished successfully 11.4 RSeQC reference files We download the human annotation bed file including the whole genome bed file, and house keeping bed file from RSeQC page from sourcforge website. ./ref_files/refseqGenes.bed ./ref_files/housekeeping_refseqGenes.bed 11.5 build salmon index conda activate rna ## salmon Version: salmon 1.1.0 salmon index -t GRCh38.d1.vd1.CIDC.fa -i salmon_index ... index [&quot;salmon_index&quot;] did not previously exist . . . creating it [jLog] [info] building index [jointLog] [info] [Step 1 of 4] : counting k-mers [jointLog] [info] Replaced 164,553,847 non-ATCG nucleotides [jointLog] [info] Clipped poly-A tails from 0 transcripts [jointLog] [info] Building rank-select dictionary and saving to disk [jointLog] [info] done Elapsed time: 0.191866s [jointLog] [info] Writing sequence data to file . . . [jointLog] [info] done Elapsed time: 1.91244s [jointLog] [info] Building 64-bit suffix array (length of generalized text is 3,088,286,426) [jointLog] [info] Building suffix array . . . success saving to disk . . . done Elapsed time: 18.3072s done Elapsed time: 703.843s 11.5.1 GMT file for gene set analysis The GMT file is downloaded from BROAD release page. The current GMT file we used is “c2.cp.kegg.v6.1.symbols.gmt” 11.6 STAR-Fusion genome resource lib The genome resource lib is downloaded from BROAD release page. The current lib we used is GRCh38_v22_CTAT_lib. You can also prep it for use with STAR-fusion. More details, read: https://github.com/STAR-Fusion/STAR-Fusion/wiki/installing-star-fusion 11.7 Centrifuge index The human Centrifuge index is downloaded from Centrifuge website. The current index we used is p_compressed+h+v that includes human genome, prokaryotic genomes, and viral genomes. You can also build your own custom Centrifuge index. For more details, read: https://github.com/DaehwanKimLab/centrifuge 11.8 TRUST4 reference files TRUST4 reference files includes 1. a TCR, BCR genomic sequence fasta file; and 2. A reference database sequence containing annotation information. hg38_bcrtcr.fa human_IMGT+C.fa These reference files can directly be downloaded from TRUST4 github. "]]
